/**
 * Antigravity Airport Aggregator - Web Backend
 * 
 * 参考 wzdnzd/aggregator 和 Mac App 的实现方式
 * 使用 Clash External Controller API 进行节点验证
 */

const fs = require('fs');
const path = require('path');
const http = require('http');
const https = require('https');
const net = require('net');
const os = require('os');
const { spawn } = require('child_process');
const yaml = require('js-yaml');

// 导入自动注册模块
let telegramRegister = null;
try {
    telegramRegister = require('./telegram_register');
} catch (e) {
    console.log('自动注册模块加载失败:', e.message);
}

// --- 配置 ---
const ROOT = __dirname;
const PORT = 3000;
const CLASH_DIR = path.join(ROOT, 'clash_bin');
const CLASH_CONFIG = path.join(CLASH_DIR, 'config.yaml');
const CLASH_PORT_HTTP = 7890;
const CLASH_EXTERNAL_CONTROLLER = '127.0.0.1:9090';

// Clash 二进制文件路径
let CLASH_BIN = '';
const platform = os.platform();
const arch = os.arch();

if (platform === 'darwin') {
    CLASH_BIN = path.join(CLASH_DIR, 'clash-darwin');
} else if (platform === 'linux') {
    if (arch === 'x64') CLASH_BIN = path.join(CLASH_DIR, 'clash-linux-amd64');
    else if (arch === 'arm64') CLASH_BIN = path.join(CLASH_DIR, 'clash-linux-arm64');
    else CLASH_BIN = path.join(CLASH_DIR, 'clash-linux-amd64');
} else {
    CLASH_BIN = path.join(CLASH_DIR, 'clash-windows-amd64.exe');
}

// 动态查找 Clash 二进制
if (!fs.existsSync(CLASH_BIN)) {
    try {
        const files = fs.readdirSync(CLASH_DIR);
        const bin = files.find(f => f.includes('clash') && !f.endsWith('.yaml'));
        if (bin) CLASH_BIN = path.join(CLASH_DIR, bin);
    } catch (e) { }
}

const MIME_TYPES = {
    '.html': 'text/html',
    '.css': 'text/css',
    '.js': 'text/javascript',
    '.json': 'application/json',
    '.png': 'image/png',
    '.jpg': 'image/jpeg',
    '.svg': 'image/svg+xml',
    '.yaml': 'text/yaml'
};

// 全局状态
const globalState = {
    status: 'idle', // idle, fetching, testing
    total: 0,
    active: 0,
    logs: [],
    lastUpdated: null
};

// Telegram 频道任务状态
const telegramState = {
    isRunning: false,
    lastRun: null,
    nextRun: null,
    intervalId: null,
    intervalMinutes: 30, // 默认每30分钟执行一次
    stats: {
        sitesScanned: 0,
        subscriptionsFound: 0,
        nodesImported: 0,
        errors: 0
    },
    currentTask: '', // 当前正在处理的任务描述
    progressLog: [] // 简短的进度日志
};

function addTelegramLog(msg, type = 'info') {
    const timestamp = new Date().toLocaleTimeString();
    console.log(`[TG] [${timestamp}] [${type.toUpperCase()}] ${msg}`);
    telegramState.progressLog.push({ timestamp, type, msg });
    // 保留最近100条日志
    if (telegramState.progressLog.length > 100) telegramState.progressLog.shift();
}

function addLog(msg, type = 'info') {
    const timestamp = new Date().toLocaleTimeString();
    console.log(`[${timestamp}] [${type.toUpperCase()}] ${msg}`);
    globalState.logs.push({ timestamp, type, msg });
    if (globalState.logs.length > 500) globalState.logs.shift();
}

// 确保目录存在
if (!fs.existsSync(CLASH_DIR)) fs.mkdirSync(CLASH_DIR, { recursive: true });

// --- 订阅源 ---
const SUBSCRIPTION_URLS = [
    'https://raw.githubusercontent.com/ermaozi/get_subscribe/main/subscribe/v2ray.txt',
    'https://raw.githubusercontent.com/mianfeifq/share/main/data',
    'https://raw.githubusercontent.com/mahdibland/V2RayAggregator/master/EternityAirConfig64.txt',
    'https://raw.githubusercontent.com/Pawdroid/Free-servers/main/sub',
    'https://raw.githubusercontent.com/freefq/free/master/v2',
    'https://raw.githubusercontent.com/aiboboxx/v2rayfree/main/v2',
    'https://raw.githubusercontent.com/peasoft/NoMoreWalls/master/list.txt',
];

// --- HTTP 请求工具 ---
function fetchUrl(url, timeout = 15000, customHeaders = {}) {
    return new Promise((resolve, reject) => {
        const client = url.startsWith('https') ? https : http;
        const timer = setTimeout(() => reject(new Error('Timeout')), timeout);

        const defaultHeaders = {
            'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
            'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8',
            'Accept-Language': 'en-US,en;q=0.5'
        };

        client.get(url, {
            headers: { ...defaultHeaders, ...customHeaders },
            timeout: timeout
        }, (res) => {
            clearTimeout(timer);
            if (res.statusCode >= 300 && res.statusCode < 400 && res.headers.location) {
                return fetchUrl(res.headers.location, timeout, customHeaders).then(resolve).catch(reject);
            }
            let data = '';
            res.on('data', chunk => data += chunk);
            res.on('end', () => resolve(data));
        }).on('error', (err) => {
            clearTimeout(timer);
            reject(err);
        });
    });
}

// 加载 Linux.do Cookie
function getLinuxDoCookie() {
    const configPath = path.join(ROOT, 'linuxdo_cookie.txt');
    try {
        if (fs.existsSync(configPath)) {
            return fs.readFileSync(configPath, 'utf8').trim();
        }
    } catch (e) { }
    return '';
}

// 使用 curl 命令获取 linux.do 内容（绕过 Cloudflare 拦截）
function fetchLinuxDo(url, cookie = '') {
    return new Promise((resolve, reject) => {
        const curlArgs = [
            '-s',
            '-H', 'Accept: application/json',
            '-H', 'User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36'
        ];

        if (cookie) {
            curlArgs.push('-H', `Cookie: ${cookie}`);
        }

        curlArgs.push(url);

        const child = spawn('curl', curlArgs, { timeout: 30000 });
        let data = '';
        let error = '';

        child.stdout.on('data', chunk => data += chunk);
        child.stderr.on('data', chunk => error += chunk);

        child.on('close', code => {
            if (code === 0 && data) {
                resolve(data);
            } else {
                reject(new Error(error || `curl exited with code ${code}`));
            }
        });

        child.on('error', err => reject(err));
    });
}

// Base64 解码
function decodeBase64(str) {
    try {
        return Buffer.from(str.replace(/-/g, '+').replace(/_/g, '/'), 'base64').toString('utf-8');
    } catch (e) { return ''; }
}

// --- Telegram 频道抓取功能 ---
const TELEGRAM_CHANNEL_URL = 'https://t.me/s/jichang_list';
const TELEGRAM_PROXIES_FILE = path.join(ROOT, 'telegram_proxies.json');

// 从 Telegram 频道提取机场网址
async function fetchTelegramAirports() {
    addTelegramLog('开始从 Telegram 频道获取机场列表...', 'info');
    telegramState.currentTask = '正在获取 Telegram 频道内容...';

    try {
        // 使用 curl 获取 Telegram 页面
        const html = await new Promise((resolve, reject) => {
            const child = spawn('curl', [
                '-s',
                '-H', 'User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36',
                '-H', 'Accept: text/html,application/xhtml+xml',
                TELEGRAM_CHANNEL_URL
            ], { timeout: 60000 });

            let data = '';
            child.stdout.on('data', chunk => data += chunk);
            child.on('close', code => code === 0 ? resolve(data) : reject(new Error(`curl failed: ${code}`)));
            child.on('error', reject);
        });

        // 提取机场网址（匹配 https://xxx.xxx 格式的链接）
        const urlPattern = /https?:\/\/[a-zA-Z0-9][-a-zA-Z0-9]*\.[a-zA-Z0-9][-a-zA-Z0-9.]*[a-zA-Z0-9](?:\/[^\s<>"']*)?/g;
        const allUrls = html.match(urlPattern) || [];

        // 过滤掉 Telegram 相关链接和无效链接
        const airportUrls = [...new Set(allUrls)].filter(url => {
            const lower = url.toLowerCase();
            return !lower.includes('t.me') &&
                !lower.includes('telegram.org') &&
                !lower.includes('github.com') &&
                !lower.includes('google.com') &&
                !lower.includes('twitter.com') &&
                !lower.includes('youtube.com') &&
                !lower.includes('facebook.com') &&
                url.length < 100;
        });

        addTelegramLog(`从频道发现 ${airportUrls.length} 个机场网址`, 'success');
        return airportUrls;
    } catch (e) {
        addTelegramLog(`获取频道失败: ${e.message}`, 'error');
        telegramState.stats.errors++;
        return [];
    }
}

// 尝试从机场网站获取订阅链接
async function tryGetSubscription(siteUrl) {
    try {
        // 常见的订阅路径
        const subPaths = [
            '/api/v1/client/subscribe?token=free',
            '/sub?token=free',
            '/subscribe?token=free',
            '/api/subscribe?token=free',
            '/clash?token=free',
            '/v2ray?token=free',
        ];

        // 首先尝试访问主页获取订阅链接
        let baseUrl = siteUrl.replace(/\/+$/, '');

        // 尝试直接访问网站
        for (const subPath of subPaths) {
            const fullUrl = baseUrl + subPath;
            try {
                const content = await fetchUrl(fullUrl, 8000);
                if (content && (content.includes('://') || content.length > 50)) {
                    // 检查是否包含有效节点
                    const parsed = parseContent(content);
                    if (parsed.length > 0) {
                        return { url: fullUrl, nodes: parsed };
                    }
                }
            } catch (e) {
                // 继续尝试下一个路径
            }
        }

        return null;
    } catch (e) {
        return null;
    }
}

// 执行 Telegram 频道抓取任务
async function runTelegramTask() {
    if (telegramState.isRunning) {
        addTelegramLog('任务已在运行中，跳过...', 'warning');
        return;
    }

    telegramState.isRunning = true;
    telegramState.lastRun = new Date().toISOString();
    telegramState.stats = { sitesScanned: 0, subscriptionsFound: 0, nodesImported: 0, registrations: 0, errors: 0 };

    addTelegramLog('========== 开始 Telegram 机场抓取任务 ==========', 'info');

    try {
        // 1. 获取机场列表
        const airports = await fetchTelegramAirports();

        if (airports.length === 0) {
            addTelegramLog('未找到机场网址', 'warning');
            telegramState.isRunning = false;
            return;
        }

        // 2. 加载现有的 Telegram 节点
        let existingNodes = [];
        try {
            if (fs.existsSync(TELEGRAM_PROXIES_FILE)) {
                existingNodes = JSON.parse(fs.readFileSync(TELEGRAM_PROXIES_FILE, 'utf8'));
            }
        } catch (e) { }

        const existingRaws = new Set(existingNodes.map(n => n.raw));
        const newNodes = [];

        // 3. 遍历机场尝试获取订阅
        const maxSites = Math.min(airports.length, 30); // 限制最多处理30个网站
        for (let i = 0; i < maxSites; i++) {
            const site = airports[i];
            telegramState.currentTask = `[${i + 1}/${maxSites}] 正在扫描: ${site.substring(0, 40)}...`;
            telegramState.stats.sitesScanned++;

            addTelegramLog(`[${i + 1}/${maxSites}] 尝试访问: ${site}`, 'info');

            try {
                // 首先尝试直接获取订阅（免登录）
                let result = await tryGetSubscription(site);

                // 如果直接获取失败，尝试自动注册
                if ((!result || result.nodes.length === 0) && telegramRegister) {
                    addTelegramLog(`  → 直接获取失败，尝试自动注册...`, 'info');
                    telegramState.currentTask = `[${i + 1}/${maxSites}] 注册中: ${site.substring(0, 35)}...`;

                    const regResult = await telegramRegister.tryRegisterSite(site);

                    if (regResult.success && regResult.subscriptionUrl) {
                        telegramState.stats.registrations++;
                        addTelegramLog(`  ✓ 注册成功，获取订阅: ${regResult.subscriptionUrl}`, 'success');

                        // 获取订阅内容
                        try {
                            const subContent = await fetchUrl(regResult.subscriptionUrl, 15000);
                            if (subContent) {
                                const parsed = parseContent(subContent);
                                if (parsed.length > 0) {
                                    result = { url: regResult.subscriptionUrl, nodes: parsed };
                                }
                            }
                        } catch (e) {
                            addTelegramLog(`  获取订阅内容失败: ${e.message}`, 'warning');
                        }
                    }
                }

                if (result && result.nodes.length > 0) {
                    telegramState.stats.subscriptionsFound++;
                    addTelegramLog(`  ✓ 发现 ${result.nodes.length} 个节点`, 'success');

                    // 标记来源并添加
                    for (const node of result.nodes) {
                        node.isFromTelegram = true;
                        node.telegramSource = 'jichang_list';
                        node.importedAt = new Date().toISOString();
                        node.siteUrl = site;

                        if (!existingRaws.has(node.raw)) {
                            newNodes.push(node);
                            existingRaws.add(node.raw);
                        }
                    }
                }
            } catch (e) {
                telegramState.stats.errors++;
                addTelegramLog(`  ✗ 错误: ${e.message}`, 'error');
            }

            // 每处理3个网站暂停一下，避免请求过快
            if ((i + 1) % 3 === 0) {
                await new Promise(r => setTimeout(r, 2000));
            }
        }

        // 4. 保存新节点
        if (newNodes.length > 0) {
            const allNodes = [...existingNodes, ...newNodes];
            // 只保留最近7天的节点
            const cutoffTime = Date.now() - 7 * 24 * 60 * 60 * 1000;
            const recentNodes = allNodes.filter(n => {
                const importTime = new Date(n.importedAt || 0).getTime();
                return importTime > cutoffTime;
            });

            fs.writeFileSync(TELEGRAM_PROXIES_FILE, JSON.stringify(recentNodes, null, 2));
            telegramState.stats.nodesImported = newNodes.length;
            addTelegramLog(`保存了 ${newNodes.length} 个新节点，总计 ${recentNodes.length} 个`, 'success');
        }

        addTelegramLog(`任务完成！扫描 ${telegramState.stats.sitesScanned} 个网站，注册 ${telegramState.stats.registrations} 个，发现 ${telegramState.stats.subscriptionsFound} 个订阅，导入 ${telegramState.stats.nodesImported} 个节点`, 'success');

    } catch (e) {
        addTelegramLog(`任务出错: ${e.message}`, 'error');
        telegramState.stats.errors++;
    } finally {
        telegramState.isRunning = false;
        telegramState.currentTask = '';
        telegramState.nextRun = new Date(Date.now() + telegramState.intervalMinutes * 60 * 1000).toISOString();
    }
}


// 启动/停止定时任务
function startTelegramScheduler(intervalMinutes = 30) {
    if (telegramState.intervalId) {
        clearInterval(telegramState.intervalId);
    }

    telegramState.intervalMinutes = intervalMinutes;
    telegramState.intervalId = setInterval(runTelegramTask, intervalMinutes * 60 * 1000);
    telegramState.nextRun = new Date(Date.now() + intervalMinutes * 60 * 1000).toISOString();

    addTelegramLog(`定时任务已启动，每 ${intervalMinutes} 分钟执行一次`, 'info');

    // 立即执行一次
    runTelegramTask();
}

function stopTelegramScheduler() {
    if (telegramState.intervalId) {
        clearInterval(telegramState.intervalId);
        telegramState.intervalId = null;
        telegramState.nextRun = null;
        addTelegramLog('定时任务已停止', 'info');
    }
}


function parseContent(content) {
    const proxies = [];

    // 尝试 Base64 解码
    let decoded = content;
    if (!content.includes('proxies:') && !content.trim().startsWith('{') && !content.includes('://')) {
        const maybeDecoded = decodeBase64(content.trim());
        if (maybeDecoded && maybeDecoded.includes('://')) {
            decoded = maybeDecoded;
        }
    }

    // YAML 格式 (Clash)
    if (decoded.includes('proxies:')) {
        try {
            const parsed = yaml.load(decoded);
            if (parsed && Array.isArray(parsed.proxies)) {
                return parsed.proxies.map((p, i) => ({
                    ...p,
                    id: `p_${Date.now()}_${i}_${Math.random().toString(36).substr(2, 5)}`
                }));
            }
        } catch (e) { }
    }

    // 逐行解析 (vmess://, vless://, trojan://, ss://, hysteria2://)
    const lines = decoded.split(/[\r\n]+/);
    for (const rawLine of lines) {
        const line = rawLine.trim();
        if (!line) continue;

        try {
            if (line.startsWith('vmess://')) {
                const b64 = line.substring(8);
                const json = JSON.parse(decodeBase64(b64));
                if (json && json.add) {
                    proxies.push({
                        id: `p_${Date.now()}_${proxies.length}_${Math.random().toString(36).substr(2, 5)}`,
                        name: json.ps || 'VMess',
                        type: 'vmess',
                        server: json.add,
                        port: parseInt(json.port, 10) || 443,
                        uuid: json.id,
                        alterId: parseInt(json.aid, 10) || 0,
                        cipher: 'auto',
                        network: json.net || 'tcp',
                        tls: json.tls === 'tls',
                        'skip-cert-verify': true,
                        'ws-opts': json.net === 'ws' ? { path: json.path || '/', headers: json.host ? { Host: json.host } : undefined } : undefined,
                        servername: json.sni || json.host,
                        raw: line
                    });
                }
            } else if (line.startsWith('vless://') || line.startsWith('trojan://')) {
                const type = line.startsWith('vless') ? 'vless' : 'trojan';
                const url = new URL(line);
                const params = Object.fromEntries(url.searchParams);

                const proxy = {
                    id: `p_${Date.now()}_${proxies.length}_${Math.random().toString(36).substr(2, 5)}`,
                    name: decodeURIComponent(url.hash.slice(1)) || type,
                    type: type,
                    server: url.hostname,
                    port: parseInt(url.port, 10) || 443,
                    uuid: type === 'vless' ? url.username : undefined,
                    password: type === 'trojan' ? url.username : undefined,
                    tls: params.security === 'tls' || params.security === 'reality' || type === 'trojan',
                    'skip-cert-verify': true,
                    network: params.type || 'tcp',
                    servername: params.sni || params.host,
                    flow: params.flow,
                    raw: line
                };

                if (params.security === 'reality') {
                    proxy['reality-opts'] = {
                        'public-key': params.pbk,
                        'short-id': params.sid
                    };
                    proxy['client-fingerprint'] = params.fp || 'chrome';
                }

                if (proxy.network === 'ws') {
                    proxy['ws-opts'] = { path: params.path || '/', headers: params.host ? { Host: params.host } : undefined };
                } else if (proxy.network === 'grpc') {
                    proxy['grpc-opts'] = { 'grpc-service-name': params.serviceName || 'grpc' };
                }

                proxies.push(proxy);
            } else if (line.startsWith('ss://')) {
                // SS 解析
                try {
                    const url = new URL(line);
                    let tag = url.hash.slice(1);
                    if (tag) tag = decodeURIComponent(tag);

                    // 解析 userinfo (method:password)
                    let method = 'aes-256-gcm', password = '';
                    if (url.username) {
                        const decoded = decodeBase64(url.username);
                        if (decoded.includes(':')) {
                            [method, password] = decoded.split(':', 2);
                        } else {
                            password = url.username;
                        }
                    }

                    if (url.hostname) {
                        proxies.push({
                            id: `p_${Date.now()}_${proxies.length}_${Math.random().toString(36).substr(2, 5)}`,
                            name: tag || 'SS',
                            type: 'ss',
                            server: url.hostname,
                            port: parseInt(url.port, 10) || 443,
                            cipher: method,
                            password: password,
                            raw: line
                        });
                    }
                } catch (e) { }
            } else if (line.startsWith('hysteria2://') || line.startsWith('hy2://')) {
                try {
                    const normalized = line.replace('hysteria2://', 'https://').replace('hy2://', 'https://');
                    const url = new URL(normalized);
                    proxies.push({
                        id: `p_${Date.now()}_${proxies.length}_${Math.random().toString(36).substr(2, 5)}`,
                        name: decodeURIComponent(url.hash.slice(1)) || 'Hysteria2',
                        type: 'hysteria2',
                        server: url.hostname,
                        port: parseInt(url.port, 10) || 443,
                        password: url.username,
                        sni: url.searchParams.get('sni') || url.hostname,
                        'skip-cert-verify': true,
                        raw: line
                    });
                } catch (e) { }
            }
        } catch (e) { }
    }

    return proxies;
}

// 去重
function removeDuplicates(proxies) {
    const map = new Map();
    for (const p of proxies) {
        if (!p.server || !p.port) continue;
        // 使用 server:port:uuid/password 作为唯一键
        const key = `${p.server}:${p.port}:${p.uuid || p.password || ''}`;
        if (!map.has(key)) {
            map.set(key, p);
        }
    }
    return Array.from(map.values());
}

// --- 获取订阅 ---
async function fetchSubscriptions() {
    let allProxies = [];

    addLog(`开始从 ${SUBSCRIPTION_URLS.length} 个订阅源获取节点...`, 'info');

    // 并发获取所有订阅
    const results = await Promise.allSettled(
        SUBSCRIPTION_URLS.map(async (url) => {
            try {
                addLog(`正在获取: ${url.substring(0, 60)}...`, 'info');
                const content = await fetchUrl(url);
                const proxies = parseContent(content);
                addLog(`从 ${url.split('/')[4] || 'source'} 获取到 ${proxies.length} 个节点`, 'success');
                return proxies;
            } catch (e) {
                addLog(`获取失败: ${url.split('/')[4] || url} - ${e.message}`, 'error');
                return [];
            }
        })
    );

    for (const result of results) {
        if (result.status === 'fulfilled' && Array.isArray(result.value)) {
            allProxies = allProxies.concat(result.value);
        }
    }

    // 调用 Python Crawler (可选)
    try {
        addLog('启动 Python 爬虫 (collect.py)...', 'info');
        const pythonProxies = await runPythonCrawler();
        addLog(`Python 爬虫获取到 ${pythonProxies.length} 个节点`, 'success');
        allProxies = allProxies.concat(pythonProxies);
    } catch (e) {
        addLog(`Python 爬虫失败: ${e.message}`, 'warning');
    }

    const unique = removeDuplicates(allProxies);
    addLog(`总计获取 ${unique.length} 个唯一节点 (去重前: ${allProxies.length})`, 'info');
    return unique;
}

// 执行 Python 脚本
async function runPythonCrawler() {
    const pythonEnv = path.join(ROOT, 'myenv/bin/python3');
    const scriptDir = path.join(ROOT, 'Projects/Aggregator/docs/Aggregator_Mac/external/aggregator');
    const scriptFile = 'subscribe/collect.py';
    const outputFile = path.join(scriptDir, 'data/clash.yaml');

    return new Promise((resolve, reject) => {
        if (!fs.existsSync(pythonEnv)) {
            return reject(new Error('Python 环境未找到'));
        }

        const child = spawn(pythonEnv, [scriptFile, '--skip', '--overwrite', '--invisible'], {
            cwd: scriptDir,
            timeout: 300000 // 5分钟超时
        });

        child.stdout.on('data', d => {
            const lines = d.toString().trim().split('\n');
            lines.forEach(line => { if (line) addLog(line, 'info'); });
        });

        child.stderr.on('data', d => {
            const lines = d.toString().trim().split('\n');
            lines.forEach(line => {
                if (line) {
                    const type = line.toLowerCase().includes('error') ? 'error' : 'info';
                    addLog(line, type);
                }
            });
        });

        child.on('close', (code) => {
            addLog(`Python 脚本退出，代码: ${code}`, code === 0 ? 'success' : 'warning');
            if (fs.existsSync(outputFile)) {
                try {
                    const content = fs.readFileSync(outputFile, 'utf8');
                    const parsed = yaml.load(content);
                    if (parsed && Array.isArray(parsed.proxies)) {
                        return resolve(parsed.proxies);
                    }
                } catch (e) {
                    addLog(`解析 Python 输出失败: ${e.message}`, 'error');
                }
            }
            resolve([]);
        });

        child.on('error', (err) => {
            addLog(`启动 Python 失败: ${err.message}`, 'error');
            resolve([]);
        });
    });
}

// --- Clash 配置生成 ---
function generateClashConfig(proxies) {
    const uniqueNames = new Set();
    const proxyList = [];

    for (const p of proxies) {
        // 净化名称
        let name = (p.name || 'node').replace(/[,"]/g, '').trim();
        if (!name) name = `node_${Math.random().toString(36).substr(2, 5)}`;

        // 确保名称唯一
        let finalName = name;
        let counter = 1;
        while (uniqueNames.has(finalName)) {
            finalName = `${name}_${counter++}`;
        }
        uniqueNames.add(finalName);

        // 构建代理对象
        const proxy = {
            name: finalName,
            type: p.type,
            server: p.server,
            port: parseInt(p.port, 10) || 443
        };

        // 根据类型添加字段
        if (p.type === 'vmess') {
            proxy.uuid = p.uuid;
            proxy.alterId = p.alterId || 0;
            proxy.cipher = p.cipher || 'auto';
            if (p.network) proxy.network = p.network;
            if (p.tls) proxy.tls = true;
            if (p['skip-cert-verify']) proxy['skip-cert-verify'] = true;
            if (p.servername) proxy.servername = p.servername;
            if (p['ws-opts']) proxy['ws-opts'] = p['ws-opts'];
        } else if (p.type === 'vless') {
            proxy.uuid = p.uuid;
            if (p.flow) proxy.flow = p.flow;
            if (p.network) proxy.network = p.network;
            if (p.tls) proxy.tls = true;
            if (p['skip-cert-verify']) proxy['skip-cert-verify'] = true;
            if (p.servername) proxy.servername = p.servername;
            if (p['reality-opts']) proxy['reality-opts'] = p['reality-opts'];
            if (p['client-fingerprint']) proxy['client-fingerprint'] = p['client-fingerprint'];
            if (p['ws-opts']) proxy['ws-opts'] = p['ws-opts'];
            if (p['grpc-opts']) proxy['grpc-opts'] = p['grpc-opts'];
        } else if (p.type === 'trojan') {
            proxy.password = p.password;
            if (p.network) proxy.network = p.network;
            proxy.tls = true;
            if (p['skip-cert-verify']) proxy['skip-cert-verify'] = true;
            if (p.servername) proxy.servername = p.servername;
            if (p['ws-opts']) proxy['ws-opts'] = p['ws-opts'];
            if (p['grpc-opts']) proxy['grpc-opts'] = p['grpc-opts'];
        } else if (p.type === 'ss') {
            proxy.cipher = p.cipher || 'aes-256-gcm';
            proxy.password = p.password;
        } else if (p.type === 'hysteria2') {
            proxy.password = p.password;
            if (p.sni) proxy.sni = p.sni;
            if (p['skip-cert-verify']) proxy['skip-cert-verify'] = true;
        } else {
            continue; // 跳过不支持的类型
        }

        // 清理 undefined 值
        Object.keys(proxy).forEach(key => {
            if (proxy[key] === undefined) delete proxy[key];
        });

        proxyList.push(proxy);

        // 保存原始名称映射
        p._clashName = finalName;
    }

    const config = {
        'mixed-port': CLASH_PORT_HTTP,
        'external-controller': CLASH_EXTERNAL_CONTROLLER,
        mode: 'Global',
        'log-level': 'warning',
        dns: {
            enable: true,
            nameserver: ['223.5.5.5', '119.29.29.29', '8.8.8.8', '1.1.1.1']
        },
        proxies: proxyList,
        'proxy-groups': [
            {
                name: 'PROXY',
                type: 'select',
                proxies: Array.from(uniqueNames)
            }
        ],
        rules: ['MATCH,PROXY']
    };

    fs.writeFileSync(CLASH_CONFIG, yaml.dump(config, { lineWidth: -1 }));
    addLog(`Clash 配置已生成，包含 ${proxyList.length} 个代理`, 'info');
    return proxyList;
}

// --- Clash 进程管理 ---
let clashProcess = null;

function startClash() {
    return new Promise((resolve, reject) => {
        if (clashProcess) {
            try { clashProcess.kill('SIGTERM'); } catch (e) { }
            clashProcess = null;
        }

        addLog(`启动 Clash: ${CLASH_BIN}`, 'info');

        clashProcess = spawn(CLASH_BIN, ['-d', CLASH_DIR, '-f', CLASH_CONFIG], {
            stdio: ['ignore', 'pipe', 'pipe']
        });

        clashProcess.stdout.on('data', d => {
            const msg = d.toString().trim();
            if (msg) console.log('Clash:', msg);
        });

        clashProcess.stderr.on('data', d => {
            const msg = d.toString().trim();
            if (msg) console.error('ClashErr:', msg);
        });

        clashProcess.on('error', (err) => {
            addLog(`Clash 启动失败: ${err.message}`, 'error');
            reject(err);
        });

        // 等待 Clash 启动
        let attempts = 0;
        const maxAttempts = 30;
        const checkInterval = setInterval(() => {
            attempts++;
            const socket = new net.Socket();
            socket.setTimeout(500);
            socket.on('connect', () => {
                socket.destroy();
                clearInterval(checkInterval);
                addLog('Clash 已启动', 'success');
                resolve(clashProcess);
            }).on('error', () => {
                socket.destroy();
                if (attempts >= maxAttempts) {
                    clearInterval(checkInterval);
                    reject(new Error('Clash 启动超时'));
                }
            }).on('timeout', () => {
                socket.destroy();
            });
            socket.connect(CLASH_PORT_HTTP, '127.0.0.1');
        }, 500);
    });
}

function stopClash() {
    if (clashProcess) {
        try {
            clashProcess.kill('SIGTERM');
            addLog('Clash 已停止', 'info');
        } catch (e) { }
        clashProcess = null;
    }
}

// --- 节点验证 (使用 Clash External Controller API) ---
async function checkProxyDelay(proxyName, timeout = 10000) {
    // 多个测试 URL，只要有一个成功就算有效
    const testUrls = [
        'https://www.google.com/generate_204',
        'https://www.youtube.com/s/player/23010b46/player_ias.vflset/en_US/remote.js',
        'https://cp.cloudflare.com/generate_204'
    ];

    for (const testUrl of testUrls) {
        const delay = await checkSingleUrl(proxyName, timeout, testUrl);
        if (delay > 0) return delay;
    }
    return -1;
}

async function checkSingleUrl(proxyName, timeout, testUrl) {
    return new Promise((resolve) => {
        const encodedName = encodeURIComponent(proxyName);
        const url = `http://${CLASH_EXTERNAL_CONTROLLER}/proxies/${encodedName}/delay?timeout=${timeout}&url=${encodeURIComponent(testUrl)}`;

        const req = http.get(url, { timeout: timeout + 2000 }, (res) => {
            let data = '';
            res.on('data', chunk => data += chunk);
            res.on('end', () => {
                try {
                    const result = JSON.parse(data);
                    if (result.delay && result.delay > 0 && result.delay <= timeout) {
                        resolve(result.delay);
                    } else {
                        resolve(-1);
                    }
                } catch (e) {
                    resolve(-1);
                }
            });
        });

        req.on('error', () => resolve(-1));
        req.on('timeout', () => { req.destroy(); resolve(-1); });
    });
}

// 并发验证
async function validateProxies(proxies, concurrency = 64, delay = 10000) {
    addLog(`开始验证 ${proxies.length} 个节点 (并发: ${concurrency}, 超时: ${delay}ms)`, 'info');

    let validated = 0;
    let valid = 0;

    // 分批处理
    const batchSize = concurrency;
    for (let i = 0; i < proxies.length; i += batchSize) {
        const batch = proxies.slice(i, i + batchSize);

        const results = await Promise.all(
            batch.map(async (p) => {
                const latency = await checkProxyDelay(p._clashName || p.name, delay);
                validated++;

                if (latency > 0) {
                    valid++;
                    p.latency = latency;
                    return true;
                }
                p.latency = -1;
                return false;
            })
        );

        // 更新进度
        if (validated % 100 === 0 || validated === proxies.length) {
            addLog(`验证进度: ${validated}/${proxies.length}, 有效: ${valid}`, 'info');
            globalState.active = valid;
        }
    }

    const validProxies = proxies.filter(p => p.latency > 0);
    addLog(`验证完成: ${validProxies.length}/${proxies.length} 有效`, 'success');
    return validProxies;
}

// --- 纯净度检测 ---
async function checkPurity(proxy, clashProxyName) {
    // 通过代理访问 ip-api.com 获取 IP 信息
    const testUrl = 'http://ip-api.com/json?fields=status,countryCode,isp,org,hosting,proxy,query';

    return new Promise((resolve) => {
        const encodedName = encodeURIComponent(clashProxyName);
        // 使用 Clash API 先切换到该代理
        const switchUrl = `http://${CLASH_EXTERNAL_CONTROLLER}/proxies/PROXY`;

        const postData = JSON.stringify({ name: clashProxyName });

        const switchReq = http.request(switchUrl, {
            method: 'PUT',
            headers: { 'Content-Type': 'application/json', 'Content-Length': Buffer.byteLength(postData) },
            timeout: 3000
        }, (res) => {
            // 切换成功后检测IP
            setTimeout(async () => {
                try {
                    // 通过 Clash 代理发起请求
                    const result = await fetchViaProxy(testUrl, 8000);
                    const data = JSON.parse(result);

                    if (data.status === 'success') {
                        let score = 100;

                        // 扣分规则
                        if (data.hosting === true) score -= 30; // 机房 IP
                        if (data.proxy === true) score -= 20;   // 被标记为代理

                        // ISP 关键词检测
                        const isp = (data.isp || '').toLowerCase();
                        const org = (data.org || '').toLowerCase();
                        const badKeywords = ['datacenter', 'cloud', 'hosting', 'server', 'vps', 'digital ocean', 'amazon', 'google', 'microsoft', 'alibaba', 'tencent'];
                        for (const kw of badKeywords) {
                            if (isp.includes(kw) || org.includes(kw)) {
                                score -= 10;
                                break;
                            }
                        }

                        score = Math.max(0, score);
                        resolve({ score, ip: data.query, isp: data.isp, country: data.countryCode, hosting: data.hosting });
                    } else {
                        resolve({ score: 50, error: 'API failed' }); // 默认中等分数
                    }
                } catch (e) {
                    resolve({ score: 50, error: e.message });
                }
            }, 500);
        });

        switchReq.on('error', () => resolve({ score: 50, error: 'Switch failed' }));
        switchReq.on('timeout', () => { switchReq.destroy(); resolve({ score: 50, error: 'Timeout' }); });
        switchReq.write(postData);
        switchReq.end();
    });
}

// 通过本地 Clash 代理发起 HTTP 请求
function fetchViaProxy(url, timeout = 5000) {
    return new Promise((resolve, reject) => {
        const proxyAgent = `http://127.0.0.1:${CLASH_PORT_HTTP}`;

        const parsedUrl = new URL(url);
        const options = {
            hostname: '127.0.0.1',
            port: CLASH_PORT_HTTP,
            path: url,
            method: 'GET',
            headers: {
                'Host': parsedUrl.hostname,
                'User-Agent': 'Mozilla/5.0'
            },
            timeout: timeout
        };

        const req = http.request(options, (res) => {
            let data = '';
            res.on('data', chunk => data += chunk);
            res.on('end', () => resolve(data));
        });

        req.on('error', reject);
        req.on('timeout', () => { req.destroy(); reject(new Error('Timeout')); });
        req.end();
    });
}

// 批量纯净度检测
async function checkPurityBatch(proxies, concurrency = 10) {
    addLog(`开始纯净度检测 (${proxies.length} 个节点)...`, 'info');

    let checked = 0;
    const batchSize = concurrency;

    for (let i = 0; i < proxies.length; i += batchSize) {
        const batch = proxies.slice(i, i + batchSize);

        await Promise.all(batch.map(async (p) => {
            const result = await checkPurity(p, p._clashName || p.name);
            p.purityScore = result.score;
            p.purityInfo = result;
            checked++;
        }));

        if (checked % 20 === 0 || checked === proxies.length) {
            addLog(`纯净度检测进度: ${checked}/${proxies.length}`, 'info');
        }
    }

    addLog(`纯净度检测完成`, 'success');
}

// --- 主聚合逻辑 ---
async function runAggregation() {
    if (globalState.status !== 'idle') {
        addLog('聚合任务已在运行中', 'warning');
        return;
    }

    globalState.status = 'fetching';
    globalState.logs = [];
    globalState.total = 0;
    globalState.active = 0;

    try {
        // 1. 获取节点
        addLog('========== 开始节点聚合 ==========', 'info');
        const proxies = await fetchSubscriptions();
        globalState.total = proxies.length;

        if (proxies.length === 0) {
            addLog('未获取到任何节点', 'error');
            globalState.status = 'idle';
            return;
        }

        // 2. 生成 Clash 配置
        globalState.status = 'testing';
        addLog('生成 Clash 测试配置...', 'info');
        generateClashConfig(proxies);

        // 3. 启动 Clash
        await startClash();

        // 等待 Clash 完全启动
        await new Promise(r => setTimeout(r, 3000));

        // 4. 验证节点 (放宽条件: 15秒超时, 32并发)
        addLog('========== 开始节点验证 ==========', 'info');
        const validProxies = await validateProxies(proxies, 32, 15000);

        if (validProxies.length > 0) {
            // 5. 纯净度检测 - 只对没有纯净度信息的新节点进行检查
            const proxiesNeedPurity = validProxies.filter(p => !p.purityInfo || !p.purityScore);
            if (proxiesNeedPurity.length > 0) {
                addLog(`========== 开始纯净度检测 (${proxiesNeedPurity.length}/${validProxies.length} 个新节点) ==========`, 'info');
                await checkPurityBatch(proxiesNeedPurity, 8);
            } else {
                addLog(`所有 ${validProxies.length} 个节点已有纯净度信息，跳过检测`, 'info');
            }

            // 按延迟排序
            validProxies.sort((a, b) => (a.latency || 99999) - (b.latency || 99999));
        }

        // 6. 停止 Clash
        stopClash();

        // 7. 保存结果
        if (validProxies.length > 0) {
            fs.writeFileSync(path.join(ROOT, 'proxies.json'), JSON.stringify(validProxies, null, 2));
            addLog(`已保存 ${validProxies.length} 个有效节点`, 'success');
        } else {
            addLog('未找到有效节点', 'warning');
        }

        globalState.active = validProxies.length;
        globalState.lastUpdated = new Date();
        addLog('========== 聚合完成 ==========', 'success');

    } catch (e) {
        addLog(`聚合失败: ${e.message}`, 'error');
        console.error(e);
        stopClash();
    } finally {
        globalState.status = 'idle';
    }
}

// --- 导出配置转换 ---
function proxyToClashObj(p) {
    // 验证基本必需字段
    if (!p.type || !p.server || !p.port) {
        return null;
    }

    const base = {
        name: p.name || 'node',
        type: p.type,
        server: p.server,
        port: parseInt(p.port, 10) || 443
    };

    if (p.type === 'vmess') {
        // vmess 必须有 uuid
        if (!p.uuid) return null;
        base.uuid = p.uuid;
        base.alterId = p.alterId || 0;
        base.cipher = p.cipher || 'auto';
        if (p.network) base.network = p.network;
        if (p.tls) base.tls = true;
        base['skip-cert-verify'] = true;
        if (p.udp) base.udp = true; // 保留 UDP 配置
        if (p.servername) base.servername = p.servername;
        if (p['ws-opts']) base['ws-opts'] = p['ws-opts'];
    } else if (p.type === 'vless') {
        // vless 必须有 uuid
        if (!p.uuid) return null;
        base.uuid = p.uuid;
        if (p.flow) base.flow = p.flow;
        if (p.network) base.network = p.network;
        if (p.tls) base.tls = true;
        base['skip-cert-verify'] = true;
        if (p.servername) base.servername = p.servername;
        if (p['reality-opts']) base['reality-opts'] = p['reality-opts'];
        if (p['client-fingerprint']) base['client-fingerprint'] = p['client-fingerprint'];
        if (p['ws-opts']) base['ws-opts'] = p['ws-opts'];
        if (p['grpc-opts']) base['grpc-opts'] = p['grpc-opts'];
    } else if (p.type === 'trojan') {
        // trojan 必须有 password
        if (!p.password) return null;
        base.password = p.password;
        if (p.network) base.network = p.network;
        base.tls = true;
        base['skip-cert-verify'] = true;
        if (p.servername) base.servername = p.servername;
        if (p.sni) base.sni = p.sni;
        if (p['ws-opts']) base['ws-opts'] = p['ws-opts'];
    } else if (p.type === 'ss') {
        // ss 必须有 password 和 cipher
        if (!p.password) return null;
        base.cipher = p.cipher || 'aes-256-gcm';
        base.password = p.password;
    } else if (p.type === 'hysteria2' || p.type === 'hy2') {
        // hysteria2 必须有 password
        if (!p.password) return null;
        base.type = 'hysteria2'; // 统一类型名
        base.password = p.password;
        if (p.sni) base.sni = p.sni;
        if (p.obfs) base.obfs = p.obfs;
        if (p['obfs-password']) base['obfs-password'] = p['obfs-password'];
        base['skip-cert-verify'] = true;
    } else if (p.type === 'hysteria') {
        // hysteria (v1) 需要不同的字段
        if (!p.password && !p['auth-str']) return null;
        base.auth_str = p.password || p['auth-str'];
        if (p.sni) base.sni = p.sni;
        if (p.protocol) base.protocol = p.protocol;
        if (p.up) base.up = p.up;
        if (p.down) base.down = p.down;
        base['skip-cert-verify'] = true;
    } else {
        // 不支持的类型
        return null;
    }

    // 清理 undefined 值
    Object.keys(base).forEach(key => {
        if (base[key] === undefined) delete base[key];
    });

    return base;
}


// --- HTTP 服务器 ---
const server = http.createServer(async (req, res) => {
    const headers = {
        'Access-Control-Allow-Origin': '*',
        'Access-Control-Allow-Methods': 'OPTIONS, POST, GET',
        'Access-Control-Allow-Headers': 'Content-Type',
    };

    if (req.method === 'OPTIONS') {
        res.writeHead(204, headers);
        return res.end();
    }

    const getBody = () => new Promise(resolve => {
        let body = '';
        req.on('data', chunk => body += chunk);
        req.on('end', () => {
            try { resolve(JSON.parse(body)); } catch (e) { resolve({}); }
        });
    });

    const parsedUrl = new URL(req.url, `http://${req.headers.host}`);

    // API: 刷新
    if (parsedUrl.pathname === '/api/refresh' && req.method === 'POST') {
        if (globalState.status === 'idle') {
            runAggregation(); // 异步执行
            res.writeHead(200, { 'Content-Type': 'application/json', ...headers });
            res.end(JSON.stringify({ success: true, message: '聚合任务已启动' }));
        } else {
            res.writeHead(200, { 'Content-Type': 'application/json', ...headers });
            res.end(JSON.stringify({ success: false, message: '任务进行中', status: globalState.status }));
        }
        return;
    }

    // API: 手动纯净度检查
    if (parsedUrl.pathname === '/api/check_purity' && req.method === 'POST') {
        try {
            const { proxies } = await getBody();
            if (!proxies || !Array.isArray(proxies) || proxies.length === 0) {
                res.writeHead(400, { 'Content-Type': 'application/json', ...headers });
                return res.end(JSON.stringify({ success: false, error: '没有提供节点' }));
            }

            addLog(`开始手动纯净度检查 (${proxies.length} 个节点)...`, 'info');

            const results = [];
            const batchSize = 10;

            for (let i = 0; i < proxies.length; i += batchSize) {
                const batch = proxies.slice(i, i + batchSize);

                await Promise.all(batch.map(async (p) => {
                    const result = await checkPurity(p, p._clashName || p.name);
                    results.push({
                        id: p.id,
                        server: p.server,
                        purityScore: result.score,
                        purityInfo: result
                    });
                }));

                if ((i + batchSize) % 20 === 0 || i + batchSize >= proxies.length) {
                    addLog(`纯净度检查进度: ${Math.min(i + batchSize, proxies.length)}/${proxies.length}`, 'info');
                }
            }

            addLog(`手动纯净度检查完成`, 'success');

            res.writeHead(200, { 'Content-Type': 'application/json', ...headers });
            res.end(JSON.stringify({
                success: true,
                checked: results.length,
                results: results
            }));
        } catch (e) {
            console.error('纯净度检查错误:', e);
            res.writeHead(500, { 'Content-Type': 'application/json', ...headers });
            res.end(JSON.stringify({ success: false, error: e.message }));
        }
        return;
    }

    // API: 状态
    if (parsedUrl.pathname === '/api/status' && req.method === 'GET') {
        res.writeHead(200, { 'Content-Type': 'application/json', ...headers });
        res.end(JSON.stringify(globalState));
        return;
    }

    // API: 获取节点
    if (parsedUrl.pathname === '/api/proxies' && req.method === 'GET') {
        try {
            const data = fs.readFileSync(path.join(ROOT, 'proxies.json'), 'utf8');
            res.writeHead(200, { 'Content-Type': 'application/json', ...headers });
            res.end(data);
        } catch (e) {
            res.writeHead(200, { 'Content-Type': 'application/json', ...headers });
            res.end('[]');
        }
        return;
    }

    // API: Telegram 频道任务状态
    if (parsedUrl.pathname === '/api/telegram/status' && req.method === 'GET') {
        res.writeHead(200, { 'Content-Type': 'application/json', ...headers });
        res.end(JSON.stringify({
            isRunning: telegramState.isRunning,
            lastRun: telegramState.lastRun,
            nextRun: telegramState.nextRun,
            intervalMinutes: telegramState.intervalMinutes,
            stats: telegramState.stats,
            currentTask: telegramState.currentTask,
            progressLog: telegramState.progressLog.slice(-20), // 返回最近20条日志
            isScheduled: telegramState.intervalId !== null
        }));
        return;
    }

    // API: 启动 Telegram 频道抓取（后台定时）
    if (parsedUrl.pathname === '/api/telegram/start' && req.method === 'POST') {
        let body = '';
        req.on('data', chunk => body += chunk);
        req.on('end', () => {
            try {
                const params = JSON.parse(body || '{}');
                const interval = parseInt(params.intervalMinutes) || 30;
                startTelegramScheduler(interval);
                res.writeHead(200, { 'Content-Type': 'application/json', ...headers });
                res.end(JSON.stringify({ success: true, message: `任务已启动，间隔 ${interval} 分钟` }));
            } catch (e) {
                res.writeHead(500, { 'Content-Type': 'application/json', ...headers });
                res.end(JSON.stringify({ success: false, error: e.message }));
            }
        });
        return;
    }

    // API: 停止 Telegram 频道抓取
    if (parsedUrl.pathname === '/api/telegram/stop' && req.method === 'POST') {
        stopTelegramScheduler();
        res.writeHead(200, { 'Content-Type': 'application/json', ...headers });
        res.end(JSON.stringify({ success: true, message: '任务已停止' }));
        return;
    }

    // API: 立即执行一次 Telegram 抓取
    if (parsedUrl.pathname === '/api/telegram/run' && req.method === 'POST') {
        if (telegramState.isRunning) {
            res.writeHead(200, { 'Content-Type': 'application/json', ...headers });
            res.end(JSON.stringify({ success: false, message: '任务正在运行中' }));
            return;
        }
        runTelegramTask(); // 异步执行，不等待完成
        res.writeHead(200, { 'Content-Type': 'application/json', ...headers });
        res.end(JSON.stringify({ success: true, message: '任务已开始执行' }));
        return;
    }

    // API: 获取 Telegram 导入的节点
    if (parsedUrl.pathname === '/api/telegram/proxies' && req.method === 'GET') {
        try {
            if (fs.existsSync(TELEGRAM_PROXIES_FILE)) {
                const data = fs.readFileSync(TELEGRAM_PROXIES_FILE, 'utf8');
                res.writeHead(200, { 'Content-Type': 'application/json', ...headers });
                res.end(data);
            } else {
                res.writeHead(200, { 'Content-Type': 'application/json', ...headers });
                res.end('[]');
            }
        } catch (e) {
            res.writeHead(200, { 'Content-Type': 'application/json', ...headers });
            res.end('[]');
        }
        return;
    }

    // API: 获取自动注册状态
    if (parsedUrl.pathname === '/api/telegram/register_status' && req.method === 'GET') {
        res.writeHead(200, { 'Content-Type': 'application/json', ...headers });
        if (telegramRegister) {
            res.end(JSON.stringify({
                available: true,
                ...telegramRegister.registerState,
                logs: telegramRegister.registerState.logs.slice(-30)
            }));
        } else {
            res.end(JSON.stringify({ available: false, message: '自动注册模块未加载' }));
        }
        return;
    }

    // API: 手动添加的节点 - 获取
    if (parsedUrl.pathname === '/api/manual_proxies' && req.method === 'GET') {
        const manualFile = path.join(ROOT, 'manual_proxies.json');
        try {
            const data = fs.readFileSync(manualFile, 'utf8');
            res.writeHead(200, { 'Content-Type': 'application/json', ...headers });
            res.end(data);
        } catch (e) {
            res.writeHead(200, { 'Content-Type': 'application/json', ...headers });
            res.end('[]');
        }
        return;
    }

    // API: 手动添加的节点 - 保存/添加
    if (parsedUrl.pathname === '/api/manual_proxies' && req.method === 'POST') {
        const manualFile = path.join(ROOT, 'manual_proxies.json');
        try {
            const body = await getBody();
            const proxies = body.proxies || [];

            // 读取现有数据
            let existing = [];
            if (fs.existsSync(manualFile)) {
                try {
                    existing = JSON.parse(fs.readFileSync(manualFile, 'utf8'));
                } catch (e) { existing = []; }
            }

            // 标记为手动添加
            proxies.forEach(p => {
                p.isManual = true;
                p.addedAt = new Date().toISOString();
            });

            // 合并去重 (基于 raw 字段)
            const existingRaw = new Set(existing.map(p => p.raw));
            const newProxies = proxies.filter(p => !existingRaw.has(p.raw));
            const merged = [...existing, ...newProxies];

            fs.writeFileSync(manualFile, JSON.stringify(merged, null, 2));

            res.writeHead(200, { 'Content-Type': 'application/json', ...headers });
            res.end(JSON.stringify({ success: true, added: newProxies.length, total: merged.length }));
        } catch (e) {
            res.writeHead(500, { 'Content-Type': 'application/json', ...headers });
            res.end(JSON.stringify({ success: false, error: e.message }));
        }
        return;
    }

    // API: 手动添加的节点 - 删除
    if (parsedUrl.pathname === '/api/manual_proxies' && req.method === 'DELETE') {
        const manualFile = path.join(ROOT, 'manual_proxies.json');
        try {
            const body = await getBody();
            const idsToDelete = body.ids || [];

            let existing = [];
            if (fs.existsSync(manualFile)) {
                try {
                    existing = JSON.parse(fs.readFileSync(manualFile, 'utf8'));
                } catch (e) { existing = []; }
            }

            const deleteSet = new Set(idsToDelete);
            const remaining = existing.filter(p => !deleteSet.has(p.id));

            fs.writeFileSync(manualFile, JSON.stringify(remaining, null, 2));

            res.writeHead(200, { 'Content-Type': 'application/json', ...headers });
            res.end(JSON.stringify({ success: true, deleted: existing.length - remaining.length, remaining: remaining.length }));
        } catch (e) {
            res.writeHead(500, { 'Content-Type': 'application/json', ...headers });
            res.end(JSON.stringify({ success: false, error: e.message }));
        }
        return;
    }

    // API: 清空所有节点
    if (parsedUrl.pathname === '/api/clear_all' && req.method === 'POST') {
        try {
            const proxiesFile = path.join(ROOT, 'proxies.json');
            const manualFile = path.join(ROOT, 'manual_proxies.json');
            const telegramFile = path.join(ROOT, 'telegram_proxies.json');

            // 清空所有节点文件
            fs.writeFileSync(proxiesFile, '[]');
            fs.writeFileSync(manualFile, '[]');
            if (fs.existsSync(telegramFile)) {
                fs.writeFileSync(telegramFile, '[]');
            }

            addLog('已清空所有节点文件', 'info');

            res.writeHead(200, { 'Content-Type': 'application/json', ...headers });
            res.end(JSON.stringify({ success: true, message: '已清空所有节点' }));
        } catch (e) {
            res.writeHead(500, { 'Content-Type': 'application/json', ...headers });
            res.end(JSON.stringify({ success: false, error: e.message }));
        }
        return;
    }

    // API: 从 linux.do 导入节点
    if (parsedUrl.pathname === '/api/import_linuxdo' && req.method === 'POST') {
        res.writeHead(200, { 'Content-Type': 'application/json', ...headers });

        // 不使用 Cookie，直接访问公开的 JSON API
        addLog('使用公开 API 访问 linux.do（无需登录）', 'info');

        try {
            // 使用 JSON API 获取带有"订阅节点"标签的帖子列表
            // 通过滚动分页机制获取更多帖子（目标300篇）
            const baseUrl = 'https://linux.do/tag/%E8%AE%A2%E9%98%85%E8%8A%82%E7%82%B9.json';
            addLog('开始从 linux.do 抓取帖子列表 (使用滚动分页机制)...', 'info');

            let allTopics = [];
            let page = 0;
            const targetCount = 300; // 目标获取300篇帖子
            const maxPages = 15; // 最多尝试15页，防止无限循环

            while (allTopics.length < targetCount && page < maxPages) {
                const pageUrl = page === 0 ? baseUrl : `${baseUrl}?page=${page}`;
                addLog(`正在获取第 ${page + 1} 页...`, 'info');

                try {
                    const listJson = await fetchLinuxDo(pageUrl, '');
                    const listData = JSON.parse(listJson);
                    const topics = listData.topic_list?.topics || [];

                    if (topics.length === 0) {
                        addLog(`第 ${page + 1} 页没有更多帖子，停止获取`, 'info');
                        break;
                    }

                    // 过滤重复的帖子（基于 ID）
                    const existingIds = new Set(allTopics.map(t => t.id));
                    const newTopics = topics.filter(t => !existingIds.has(t.id));

                    if (newTopics.length === 0) {
                        addLog(`第 ${page + 1} 页帖子全部重复，停止获取`, 'info');
                        break;
                    }

                    allTopics = allTopics.concat(newTopics);
                    addLog(`第 ${page + 1} 页获取 ${newTopics.length} 个新帖子，累计 ${allTopics.length} 个`, 'info');

                    page++;

                    // 小延迟避免请求过快
                    await new Promise(r => setTimeout(r, 500));
                } catch (e) {
                    addLog(`获取第 ${page + 1} 页失败: ${e.message}，继续下一页`, 'warning');
                    page++;
                }
            }

            addLog(`总共从 JSON API 获取到 ${allTopics.length} 个帖子`, 'success');

            // 过滤最近30天的帖子，最多处理300个
            const now = new Date();
            const recentTopics = allTopics.filter(t => {
                const createdAt = new Date(t.created_at);
                const daysDiff = (now - createdAt) / (1000 * 60 * 60 * 24);
                return daysDiff <= 30;
            }).slice(0, 300);

            addLog(`过滤后剩余 ${recentTopics.length} 个近30天帖子`, 'info');

            const allProxies = [];
            const allSubscriptions = [];
            let processedCount = 0;

            for (let i = 0; i < recentTopics.length; i++) {
                const topic = recentTopics[i];
                const topicId = topic.id;
                const topicTitle = topic.title || '未知标题';

                try {
                    addLog(`[${i + 1}/${recentTopics.length}] 读取帖子: ${topicTitle.substring(0, 30)}...`, 'info');

                    const topicUrl = `https://linux.do/t/topic/${topicId}.json`;
                    // 使用 curl 获取帖子内容（无 Cookie）
                    const topicJson = await fetchLinuxDo(topicUrl, '');
                    const topicData = JSON.parse(topicJson);

                    // 获取帖子内容（所有楼层）
                    const posts = topicData.post_stream?.posts || [];

                    for (const post of posts.slice(0, 10)) { // 读取前10楼
                        const content = post.cooked || '';

                        // 查找订阅链接 (更灵活的匹配)
                        // 匹配常见的订阅格式链接
                        const subPatterns = [
                            /https?:\/\/[^\s<>"'\)]+(?:subscribe|sub|api|link|clash|v2ray|vmess|trojan|ss|ssr|yaml|txt)[^\s<>"'\)]*/gi,
                            /https?:\/\/[^\s<>"'\)]+\.(yaml|txt|json)(?:\?[^\s<>"'\)]*)?/gi
                        ];

                        for (const pattern of subPatterns) {
                            const matches = content.match(pattern) || [];
                            for (let url of matches) {
                                // 清理 HTML 实体和尾部标点
                                url = url.replace(/&amp;/g, '&')
                                    .replace(/&lt;/g, '<')
                                    .replace(/&gt;/g, '>')
                                    .replace(/<[^>]+>/g, '')
                                    .replace(/[,;。，；]+$/, '')
                                    .trim();

                                // 排除明显不是订阅的链接
                                if (url.includes('github.com') && !url.includes('raw.')) continue;
                                if (url.includes('linux.do')) continue;
                                if (url.length > 500) continue;

                                if (url && !allSubscriptions.includes(url)) {
                                    allSubscriptions.push(url);
                                    addLog(`  发现订阅: ${url.substring(0, 60)}...`, 'success');
                                }
                            }
                        }

                        // 查找直接的节点链接
                        const nodePatterns = [
                            /vmess:\/\/[A-Za-z0-9+\/=_-]+/g,
                            /vless:\/\/[A-Za-z0-9@.:_\-?&=%#\/]+/g,
                            /trojan:\/\/[A-Za-z0-9@.:_\-?&=%#\/]+/g,
                            /ss:\/\/[A-Za-z0-9@.:_\-?&=%#\/]+/g,
                            /ssr:\/\/[A-Za-z0-9+\/=_-]+/g,
                            /hysteria2?:\/\/[A-Za-z0-9@.:_\-?&=%#\/]+/g,
                            /hy2:\/\/[A-Za-z0-9@.:_\-?&=%#\/]+/g
                        ];

                        for (const pattern of nodePatterns) {
                            const matches = content.match(pattern) || [];
                            for (let m of matches) {
                                // 清理
                                m = m.replace(/<[^>]+>/g, '')
                                    .replace(/&amp;/g, '&')
                                    .trim();

                                if (m && !allProxies.includes(m)) {
                                    allProxies.push(m);
                                }
                            }
                        }

                        // 查找 Base64 编码的内容（可能是节点列表）
                        const base64Pattern = /[A-Za-z0-9+\/]{50,}={0,2}/g;
                        const base64Matches = content.match(base64Pattern) || [];
                        for (const b64 of base64Matches) {
                            try {
                                const decoded = Buffer.from(b64, 'base64').toString('utf-8');
                                // 检查是否包含节点协议
                                if (decoded.includes('://')) {
                                    const lines = decoded.split(/[\r\n]+/);
                                    for (const line of lines) {
                                        const trimmed = line.trim();
                                        if (/^(vmess|vless|trojan|ss|ssr|hysteria2?|hy2):\/\//.test(trimmed)) {
                                            if (!allProxies.includes(trimmed)) {
                                                allProxies.push(trimmed);
                                            }
                                        }
                                    }
                                }
                            } catch (e) {
                                // Base64 解码失败，忽略
                            }
                        }
                    }

                    processedCount++;

                    if ((i + 1) % 5 === 0) {
                        addLog(`进度: ${i + 1}/${recentTopics.length}, 已发现 ${allSubscriptions.length} 订阅, ${allProxies.length} 节点`, 'info');
                    }
                } catch (e) {
                    addLog(`  读取帖子 ${topicId} 失败: ${e.message}`, 'warning');
                }

                // 小延迟避免请求过快
                await new Promise(r => setTimeout(r, 300));
            }

            addLog(`抓取完成！发现 ${allSubscriptions.length} 个订阅链接, ${allProxies.length} 个节点链接`, 'success');

            // 解析找到的节点
            let parsedProxies = [];
            for (const raw of allProxies) {
                const parsed = parseContent(raw);
                if (parsed.length > 0) {
                    parsedProxies = parsedProxies.concat(parsed);
                }
            }

            // 尝试获取订阅内容
            for (const subUrl of allSubscriptions.slice(0, 10)) { // 最多尝试10个订阅
                try {
                    addLog(`尝试获取订阅: ${subUrl.substring(0, 50)}...`, 'info');
                    const subContent = await fetchUrl(subUrl, 10000);
                    const subProxies = parseContent(subContent);
                    if (subProxies.length > 0) {
                        addLog(`  从订阅获取 ${subProxies.length} 个节点`, 'success');
                        parsedProxies = parsedProxies.concat(subProxies);
                    }
                } catch (e) {
                    addLog(`  订阅获取失败: ${e.message}`, 'warning');
                }
            }

            // 去重
            const uniqueProxies = removeDuplicates(parsedProxies);

            // 标记来源为论坛
            uniqueProxies.forEach(p => {
                p.isFromForum = true;
                p.forumSource = 'linux.do';
                p.importedAt = new Date().toISOString();
            });

            addLog(`解析完成，共 ${uniqueProxies.length} 个唯一节点（已标记为论坛来源）`, 'success');

            res.end(JSON.stringify({
                success: true,
                subscriptions: allSubscriptions,
                proxies: allProxies,
                parsedProxies: uniqueProxies,
                topicsProcessed: processedCount
            }));
        } catch (e) {
            addLog(`linux.do 导入失败: ${e.message}`, 'error');
            res.end(JSON.stringify({ success: false, error: e.message }));
        }
        return;
    }

    // API: 转换导出
    if (parsedUrl.pathname === '/api/convert' && req.method === 'POST') {
        try {
            const { proxies, type } = await getBody();
            if (!proxies || !Array.isArray(proxies) || proxies.length === 0) {
                res.writeHead(400, headers);
                return res.end('No proxies');
            }

            if (type === 'clash') {
                // 确保名称唯一
                const usedNames = new Set();
                const proxyList = [];

                for (const p of proxies) {
                    const obj = proxyToClashObj(p);
                    if (!obj) continue;

                    // 获取纯净度分数
                    const purityScore = p.purityScore !== undefined ? p.purityScore : 50;

                    // 净化名称 (移除特殊字符但保留原始名称结构)
                    let baseName = (obj.name || 'node').replace(/[,"']/g, '').trim();
                    if (!baseName) baseName = 'node';

                    // 确保唯一
                    let finalName = baseName;
                    let counter = 1;
                    while (usedNames.has(finalName)) {
                        finalName = `${baseName}_${counter++}`;
                    }
                    usedNames.add(finalName);
                    obj.name = finalName;
                    proxyList.push(obj);

                }

                const config = {
                    port: 7890,
                    'socks-port': 7891,
                    'allow-lan': true,
                    mode: 'Rule',
                    'log-level': 'info',
                    'external-controller': ':9090',
                    dns: {
                        enable: true,
                        listen: '0.0.0.0:53',
                        'enhanced-mode': 'fake-ip',
                        'fake-ip-range': '198.18.0.1/16',
                        'default-nameserver': ['223.5.5.5', '114.114.114.114'],
                        nameserver: ['https://dns.alidns.com/dns-query', 'https://doh.pub/dns-query'],
                        fallback: ['https://dns.google/dns-query', 'https://cloudflare-dns.com/dns-query'],
                        'fallback-filter': { geoip: true, 'geoip-code': 'CN' }
                    },
                    proxies: proxyList,
                    'proxy-groups': [
                        { name: '🚀 节点选择', type: 'select', proxies: ['♻️ 自动选择', 'DIRECT', ...proxyList.map(p => p.name)] },
                        { name: '♻️ 自动选择', type: 'url-test', url: 'http://www.gstatic.com/generate_204', interval: 300, tolerance: 50, proxies: proxyList.map(p => p.name) }
                    ],
                    rules: ['GEOIP,CN,DIRECT', 'MATCH,🚀 节点选择']
                };

                const yamlStr = yaml.dump(config, { lineWidth: -1 });
                res.writeHead(200, { ...headers, 'Content-Type': 'text/yaml', 'Content-Disposition': 'attachment; filename="clash_config.yaml"' });
                return res.end(yamlStr);
            }

            res.writeHead(400, headers);
            res.end('Unsupported Type');
        } catch (e) {
            console.error(e);
            res.writeHead(500, headers);
            res.end('Error');
        }
        return;
    }

    // API: 代理中转
    if (parsedUrl.pathname === '/api/proxy') {
        const targetUrl = parsedUrl.searchParams.get('url');
        if (!targetUrl) { res.writeHead(400, headers); res.end('Missing url'); return; }

        try {
            const content = await fetchUrl(targetUrl);

            // 检查是否返回了 HTML 页面（可能是登录页或错误页）
            if (content.includes('<!DOCTYPE') || content.includes('<html')) {
                res.writeHead(400, { 'Content-Type': 'application/json', ...headers });
                res.end(JSON.stringify({ error: '订阅链接返回了网页而非节点数据，请检查链接是否正确或是否需要登录' }));
                return;
            }

            res.writeHead(200, { 'Content-Type': 'text/plain; charset=utf-8', ...headers });
            res.end(content);
        } catch (e) {
            console.error('Proxy fetch error:', e.message);
            res.writeHead(500, { 'Content-Type': 'application/json', ...headers });
            res.end(JSON.stringify({ error: `获取订阅失败: ${e.message}` }));
        }
        return;
    }

    // API: IP 检测 (批量)
    if (parsedUrl.pathname === '/api/check_ip_batch' && req.method === 'POST') {
        let body = [];
        req.on('data', chunk => body.push(chunk));
        req.on('end', () => {
            try {
                const ips = JSON.parse(Buffer.concat(body).toString());
                if (!Array.isArray(ips)) {
                    res.writeHead(400, headers);
                    return res.end('Invalid input');
                }

                const postData = JSON.stringify(ips.map(ip => ({ query: ip, fields: 'status,countryCode,isp,hosting,query' })));

                const apiReq = http.request({
                    hostname: 'ip-api.com',
                    port: 80,
                    path: '/batch',
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json', 'Content-Length': Buffer.byteLength(postData) }
                }, (apiRes) => {
                    let data = '';
                    apiRes.on('data', chunk => data += chunk);
                    apiRes.on('end', () => {
                        res.writeHead(200, { 'Content-Type': 'application/json', ...headers });
                        res.end(data);
                    });
                });

                apiReq.on('error', () => {
                    res.writeHead(500, headers);
                    res.end('[]');
                });

                apiReq.write(postData);
                apiReq.end();
            } catch (e) {
                res.writeHead(500, headers);
                res.end('[]');
            }
        });
        return;
    }

    // 静态文件服务
    let filePath = path.join(ROOT, parsedUrl.pathname);

    // 处理目录访问：自动返回 index.html
    if (fs.existsSync(filePath) && fs.statSync(filePath).isDirectory()) {
        filePath = path.join(filePath, 'index.html');
    }

    // 根路径处理
    if (parsedUrl.pathname === '/') {
        filePath = path.join(ROOT, 'Projects', 'Aggregator', 'index.html');
    }

    if (fs.existsSync(filePath) && fs.statSync(filePath).isFile()) {
        const ext = path.extname(filePath);
        const mimeType = MIME_TYPES[ext] || 'application/octet-stream';

        res.writeHead(200, { 'Content-Type': mimeType, ...headers });
        fs.createReadStream(filePath).pipe(res);
    } else {
        res.writeHead(404, headers);
        res.end('Not Found');
    }
});

server.listen(PORT, () => {
    console.log(`\n========================================`);
    console.log(`  Antigravity Airport Aggregator`);
    console.log(`  服务器运行于 http://localhost:${PORT}`);
    console.log(`  API: /api/refresh, /api/status, /api/proxies`);
    console.log(`========================================\n`);
});

// 优雅退出
process.on('SIGINT', () => {
    console.log('\n正在关闭...');
    stopClash();
    server.close();
    process.exit(0);
});

process.on('SIGTERM', () => {
    stopClash();
    server.close();
    process.exit(0);
});