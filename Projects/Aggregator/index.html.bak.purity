<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Antigravity æœºåœºèšåˆå™¨ Web ç‰ˆ</title>
    <link rel="icon"
        href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24'%3E%3Cdefs%3E%3ClinearGradient id='g' x1='0' y1='0' x2='1' y2='1'%3E%3Cstop offset='0' stop-color='%236366f1'/%3E%3Cstop offset='1' stop-color='%239333ea'/%3E%3C/linearGradient%3E%3C/defs%3E%3Crect width='24' height='24' rx='6' fill='url(%23g)'/%3E%3Cpath fill='white' transform='scale(0.7) translate(5,5)' d='M2.5,19h19v2h-19V19z M22.07,9.64c-0.21-0.8-1.04-1.28-1.84-1.06L14.92,10l-6.9-6.4C7.65,3.23,7.12,3,6.56,3h-0.03c-0.89,0-1.42,0.92-1.03,1.67L8.71,10L4.22,10L2.1,8.35C1.65,8.02,1.01,8.12,0.67,8.56l0,0c-0.34,0.44-0.25,1.06,0.2,1.39l4.52,3.31C5.82,12.58,6.38,13,7.5,13h12.5c1.1,0,2-0.9,2-2l0,0C22,10.55,22.07,10.09,22.07,9.64z'/%3E%3C/svg%3E">
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons+Round" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #0f172a;
            /* slate-900 */
            background-image:
                radial-gradient(at 0% 0%, hsla(253, 16%, 7%, 1) 0, transparent 50%),
                radial-gradient(at 50% 0%, hsla(225, 39%, 30%, 1) 0, transparent 50%),
                radial-gradient(at 100% 0%, hsla(339, 49%, 30%, 1) 0, transparent 50%);
            background-attachment: fixed;
        }

        .glass-panel {
            background: rgba(30, 41, 59, 0.7);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .glass-input {
            background: rgba(15, 23, 42, 0.6);
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: white;
            transition: all 0.3s ease;
        }

        .glass-input:focus {
            outline: none;
            border-color: #818cf8;
            /* indigo-400 */
            box-shadow: 0 0 0 2px rgba(129, 140, 248, 0.2);
        }

        /* Custom Scrollbar */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        ::-webkit-scrollbar-track {
            background: rgba(30, 41, 59, 0.5);
        }

        ::-webkit-scrollbar-thumb {
            background: rgba(71, 85, 105, 0.8);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: rgba(148, 163, 184, 0.8);
        }

        .fade-enter-active,
        .fade-leave-active {
            transition: opacity 0.3s ease;
        }

        .fade-enter-from,
        .fade-leave-to {
            opacity: 0;
        }

        .list-enter-active,
        .list-leave-active {
            transition: all 0.4s ease;
        }

        .list-enter-from,
        .list-leave-to {
            opacity: 0;
            transform: translateY(20px);
        }
    </style>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        slate: { 850: '#151e2e' }
                    }
                }
            }
        }
    </script>
</head>

<body class="text-slate-200 min-h-screen">
    <div id="app" class="max-w-7xl mx-auto px-4 py-8 sm:px-6 lg:px-8">
        <!-- Header -->
        <header class="mb-10 flex flex-col md:flex-row justify-between items-center animate-fade-in-down">
            <div class="flex items-center space-x-4 mb-4 md:mb-0">
                <div
                    class="w-12 h-12 rounded-xl bg-gradient-to-br from-indigo-500 to-purple-600 flex items-center justify-center shadow-lg shadow-indigo-500/30">
                    <span class="material-icons-round text-white text-3xl">flight_takeoff</span>
                </div>
                <div>
                    <h1
                        class="text-3xl font-bold text-transparent bg-clip-text bg-gradient-to-r from-white to-slate-400">
                        Airport Aggregator
                    </h1>
                    <p class="text-slate-400 text-sm">Web Edition â€¢ Antigravity</p>
                </div>
            </div>
            <div class="flex space-x-3">
                <button @click="showImportParams = !showImportParams"
                    class="px-4 py-2 rounded-lg bg-slate-800 hover:bg-slate-700 border border-slate-700 transition flex items-center text-sm">
                    <span class="material-icons-round text-base mr-2">settings</span>
                    è®¾ç½®
                </button>
                <div class="relative group">
                    <div
                        class="absolute -inset-0.5 bg-gradient-to-r from-pink-600 to-purple-600 rounded-lg blur opacity-75 group-hover:opacity-100 transition duration-1000 group-hover:duration-200 animate-tilt">
                    </div>
                    <button @click="showExportModal = true"
                        class="relative px-6 py-2 bg-slate-900 rounded-lg leading-none flex items-center divide-x divide-gray-600 hover:bg-slate-800 transition">
                        <span class="flex items-center space-x-2 text-indigo-100">
                            <span class="material-icons-round text-base">cloud_download</span>
                            <span class="pr-2">å¯¼å‡ºé…ç½®</span>
                        </span>
                        <span class="pl-2 block text-indigo-400 text-xs">Clash / Singbox</span>
                    </button>
                </div>
            </div>
        </header>

        <main class="grid grid-cols-1 lg:grid-cols-12 gap-8">
            <!-- Sidebar / Controls -->
            <div class="lg:col-span-4 space-y-6">
                <!-- Cloud Aggregation Card -->
                <div class="glass-panel p-6 rounded-2xl shadow-xl relative overflow-hidden">
                    <div class="absolute -right-6 -top-6 w-24 h-24 bg-blue-500/20 rounded-full blur-2xl"></div>
                    <h2 class="text-lg font-semibold text-white mb-4 flex items-center relative z-10">
                        <span class="material-icons-round text-blue-400 mr-2">cloud_sync</span>
                        äº‘ç«¯è‡ªåŠ¨èšåˆ
                    </h2>
                    <p class="text-xs text-slate-400 mb-4 relative z-10">
                        è‡ªåŠ¨ä» GitHubã€å…¬å¼€æºæŠ“å–å…è´¹èŠ‚ç‚¹ã€‚åŸºäº Aggregator æ ¸å¿ƒé€»è¾‘ã€‚
                    </p>
                    <div class="flex gap-2 relative z-10 w-full">
                        <button @click="refreshCloud" :disabled="cloudLoading"
                            class="flex-1 py-3 rounded-xl bg-gradient-to-r from-blue-600 to-indigo-600 hover:from-blue-500 hover:to-indigo-500 text-white font-medium shadow-lg shadow-blue-600/20 transition-all active:scale-95 disabled:opacity-50 disabled:cursor-not-allowed flex justify-center items-center">
                            <span v-if="cloudLoading"
                                class="material-icons-round animate-spin mr-2 text-base">refresh</span>
                            {{ cloudLoading ? 'äº‘ç«¯èšåˆä¸­...' : 'ç«‹å³æ›´æ–°äº‘ç«¯èŠ‚ç‚¹' }}
                        </button>
                        <button @click="showLogModal = true"
                            class="px-3 py-3 rounded-xl bg-slate-700 hover:bg-slate-600 text-slate-300 font-medium shadow-lg transition-all active:scale-95 flex items-center justify-center"
                            title="æŸ¥çœ‹æ—¥å¿—è¯¦æƒ…">
                            <span class="material-icons-round text-lg">terminal</span>
                        </button>
                    </div>
                    <div v-if="cloudResult" class="mt-3 text-center text-xs text-emerald-400 animate-fade-in">
                        {{ cloudResult }}
                    </div>
                    <!-- Linux.do å¯¼å…¥æŒ‰é’® -->
                    <div class="mt-3">
                        <button @click="importFromLinuxDo" :disabled="linuxDoLoading"
                            class="w-full py-3 rounded-xl bg-gradient-to-r from-purple-600 to-pink-600 hover:from-purple-500 hover:to-pink-500 text-white font-medium shadow-lg shadow-purple-600/20 transition-all active:scale-95 disabled:opacity-50 disabled:cursor-not-allowed flex justify-center items-center">
                            <span v-if="linuxDoLoading"
                                class="material-icons-round animate-spin mr-2 text-base">refresh</span>
                            <span class="material-icons-round mr-2 text-base" v-if="!linuxDoLoading">forum</span>
                            {{ linuxDoLoading ? 'æ­£åœ¨æŠ“å–...' : 'ä» Linux.do å¯¼å…¥' }}
                        </button>
                    </div>
                    <!-- Telegram é¢‘é“æŠ“å– -->
                    <div class="mt-3">
                        <button @click="toggleTelegramTask" :disabled="telegramLoading"
                            class="w-full py-3 rounded-xl text-white font-medium shadow-lg transition-all active:scale-95 disabled:opacity-50 disabled:cursor-not-allowed flex justify-center items-center"
                            :class="telegramTaskRunning ? 'bg-gradient-to-r from-red-600 to-orange-600 hover:from-red-500 hover:to-orange-500 shadow-red-600/20' : 'bg-gradient-to-r from-blue-600 to-cyan-600 hover:from-blue-500 hover:to-cyan-500 shadow-blue-600/20'">
                            <span v-if="telegramLoading"
                                class="material-icons-round animate-spin mr-2 text-base">refresh</span>
                            <span class="material-icons-round mr-2 text-base" v-if="!telegramLoading">{{
                                telegramTaskRunning ? 'stop' : 'send' }}</span>
                            {{ telegramLoading ? 'å¤„ç†ä¸­...' : (telegramTaskRunning ? 'åœæ­¢ Telegram ä»»åŠ¡' : 'ä» Telegram é¢‘é“è·å–')
                            }}
                        </button>
                    </div>
                    <!-- Telegram ä»»åŠ¡çŠ¶æ€æ˜¾ç¤º -->
                    <div v-if="telegramStatus.isScheduled || telegramStatus.isRunning"
                        class="mt-3 p-3 rounded-xl bg-slate-800/50 border border-slate-700/50">
                        <div class="flex items-center justify-between mb-2">
                            <span class="text-xs font-medium text-blue-400 flex items-center">
                                <span class="material-icons-round text-sm mr-1">send</span>
                                Telegram é¢‘é“æŠ“å–
                            </span>
                            <span v-if="telegramStatus.isRunning" class="text-xs text-emerald-400 flex items-center">
                                <span class="material-icons-round animate-spin text-sm mr-1">sync</span>
                                è¿è¡Œä¸­
                            </span>
                            <span v-else-if="telegramStatus.isScheduled" class="text-xs text-slate-400">
                                æ¯ {{ telegramStatus.intervalMinutes }} åˆ†é’Ÿ
                            </span>
                        </div>
                        <div v-if="telegramStatus.currentTask" class="text-xs text-cyan-300 mb-2 truncate">
                            {{ telegramStatus.currentTask }}
                        </div>
                        <div class="grid grid-cols-5 gap-1 text-center text-xs">
                            <div class="bg-slate-700/50 rounded-lg p-2">
                                <div class="text-slate-400">æ‰«æ</div>
                                <div class="text-white font-semibold">{{ telegramStatus.stats?.sitesScanned || 0 }}
                                </div>
                            </div>
                            <div class="bg-slate-700/50 rounded-lg p-2">
                                <div class="text-slate-400">æ³¨å†Œ</div>
                                <div class="text-purple-400 font-semibold">{{ telegramStatus.stats?.registrations || 0
                                    }}
                                </div>
                            </div>
                            <div class="bg-slate-700/50 rounded-lg p-2">
                                <div class="text-slate-400">è®¢é˜…</div>
                                <div class="text-emerald-400 font-semibold">{{ telegramStatus.stats?.subscriptionsFound
                                    || 0 }}</div>
                            </div>
                            <div class="bg-slate-700/50 rounded-lg p-2">
                                <div class="text-slate-400">æ–°å¢</div>
                                <div class="text-blue-400 font-semibold">{{ telegramStatus.stats?.nodesImported || 0 }}
                                </div>
                            </div>
                            <div class="bg-slate-700/50 rounded-lg p-2">
                                <div class="text-slate-400">é”™è¯¯</div>
                                <div class="text-red-400 font-semibold">{{ telegramStatus.stats?.errors || 0 }}</div>
                            </div>
                        </div>
                        <div v-if="telegramStatus.lastRun" class="text-xs text-slate-500 mt-2">
                            ä¸Šæ¬¡è¿è¡Œ: {{ formatTime(telegramStatus.lastRun) }}
                        </div>
                    </div>
                    <div class="mt-3">
                        <button @click="checkLocalConnectivity" :disabled="isLocalChecking"
                            class="w-full py-3 rounded-xl bg-gradient-to-r from-emerald-600 to-teal-600 hover:from-emerald-500 hover:to-teal-500 text-white font-medium shadow-lg shadow-emerald-600/20 transition-all active:scale-95 disabled:opacity-50 disabled:cursor-not-allowed flex justify-center items-center">
                            <span v-if="isLocalChecking"
                                class="material-icons-round animate-spin mr-2 text-base">refresh</span>
                            {{ isLocalChecking ? `æµ‹è¯•ä¸­ ${localCheckProgress}` : 'ğŸš€ æœåŠ¡å™¨ç›´è¿æµ‹è¯• (Server Test)' }}
                        </button>
                    </div>
                </div>

                <!-- Input Card -->
                <div class="glass-panel p-6 rounded-2xl shadow-xl">
                    <h2 class="text-lg font-semibold text-white mb-4 flex items-center">
                        <span class="material-icons-round text-indigo-400 mr-2">add_link</span>
                        æ‰‹åŠ¨æ·»åŠ è®¢é˜…
                    </h2>

                    <div class="space-y-4">
                        <div>
                            <label class="block text-xs font-medium text-slate-400 mb-1">è®¢é˜…é“¾æ¥ (URL)</label>
                            <input v-model="inputUrl" type="text"
                                placeholder="https://airport.com/api/v1/client/subscribe..."
                                class="w-full px-4 py-3 rounded-xl glass-input placeholder-slate-600 text-sm">
                        </div>

                        <div class="relative">
                            <div class="absolute inset-0 flex items-center" aria-hidden="true">
                                <div class="w-full border-t border-slate-700"></div>
                            </div>
                            <div class="relative flex justify-center">
                                <span class="bg-slate-800 px-2 text-xs text-slate-500 rounded-full">æˆ–</span>
                            </div>
                        </div>

                        <div>
                            <label class="block text-xs font-medium text-slate-400 mb-1">åŸå§‹å†…å®¹ (Base64/VMess)</label>
                            <textarea v-model="rawContent" rows="4" placeholder="vmess://... æˆ– base64 string"
                                class="w-full px-4 py-3 rounded-xl glass-input placeholder-slate-600 text-sm font-mono"></textarea>
                        </div>

                        <button @click="parseContent" :disabled="loading"
                            class="w-full py-3 rounded-xl bg-slate-700 hover:bg-slate-600 text-white font-medium transition-all active:scale-95 disabled:opacity-50 disabled:cursor-not-allowed flex justify-center items-center">
                            <span v-if="loading" class="material-icons-round animate-spin mr-2 text-base">refresh</span>
                            {{ loading ? 'è§£æä¸­...' : 'è§£æå¹¶å¯¼å…¥' }}
                        </button>

                        <p v-if="errorMsg" class="text-red-400 text-xs mt-2 flex items-center">
                            <span class="material-icons-round text-sm mr-1">error_outline</span>
                            {{ errorMsg }}
                        </p>
                    </div>
                </div>

                <!-- Stats Card -->
                <div v-if="proxies.length > 0" class="glass-panel p-6 rounded-2xl shadow-xl animate-fade-in-up">
                    <h2 class="text-lg font-semibold text-white mb-4 flex items-center">
                        <span class="material-icons-round text-emerald-400 mr-2">analytics</span>
                        èŠ‚ç‚¹ç»Ÿè®¡
                    </h2>
                    <div class="grid grid-cols-2 gap-4">
                        <div class="bg-slate-800/50 p-4 rounded-xl text-center">
                            <div class="text-3xl font-bold text-white">{{ proxies.length }}</div>
                            <div class="text-xs text-slate-400 uppercase tracking-wider mt-1">æ€»èŠ‚ç‚¹</div>
                        </div>
                        <div class="bg-slate-800/50 p-4 rounded-xl text-center">
                            <div class="text-3xl font-bold text-indigo-400">{{ protocols.length }}</div>
                            <div class="text-xs text-slate-400 uppercase tracking-wider mt-1">åè®®ç±»å‹</div>
                        </div>
                    </div>
                    <div class="mt-4 space-y-2">
                        <div v-for="(count, type) in protocolStats" :key="type"
                            class="flex items-center justify-between text-sm">
                            <span class="text-slate-400 uppercase">{{ type }}</span>
                            <div class="flex items-center">
                                <div class="w-24 h-1.5 bg-slate-700 rounded-full mr-3 overflow-hidden">
                                    <div class="h-full bg-indigo-500 rounded-full"
                                        :style="{ width: (count / proxies.length * 100) + '%' }"></div>
                                </div>
                                <span class="text-white font-mono">{{ count }}</span>
                            </div>
                        </div>
                    </div>

                    <button @click="clearProxies"
                        class="w-full mt-4 py-2 rounded-lg bg-red-500/10 hover:bg-red-500/20 text-red-500 text-sm transition">
                        æ¸…ç©ºæ‰€æœ‰èŠ‚ç‚¹
                    </button>
                </div>
            </div>

            <!-- Main Content / List -->
            <div class="lg:col-span-8">
                <div v-if="proxies.length === 0"
                    class="h-full flex flex-col items-center justify-center text-center p-10 border-2 border-dashed border-slate-700 rounded-3xl opacity-50">
                    <span class="material-icons-round text-6xl text-slate-600 mb-4">dns</span>
                    <h3 class="text-xl font-medium text-slate-300">æš‚æ— èŠ‚ç‚¹æ•°æ®</h3>
                    <p class="text-slate-500 mt-2 max-w-sm">è¯·åœ¨å·¦ä¾§æ·»åŠ è®¢é˜…é“¾æ¥æˆ–ç²˜è´´åŸå§‹å†…å®¹ä»¥å¼€å§‹ä½¿ç”¨ã€‚</p>
                </div>

                <div v-else class="space-y-4">

                    <!-- Protocol Filters -->
                    <div class="flex flex-wrap gap-2 mb-2 animate-fade-in">
                        <button @click="filterType = 'all'"
                            class="px-3 py-1.5 rounded-lg text-xs font-bold transition border uppercase flex items-center shadow-sm"
                            :class="filterType === 'all' ? 'bg-indigo-600 border-indigo-600 text-white shadow-indigo-500/30' : 'bg-slate-800 border-slate-700/50 text-slate-400 hover:text-white hover:border-slate-600'">
                            All Protocols
                            <span class="ml-2 bg-black/20 px-1.5 rounded text-[10px]">{{ totalVisibleCount }}</span>
                        </button>
                        <button v-for="proto in protocols" :key="proto" @click="filterType = proto"
                            class="px-3 py-1.5 rounded-lg text-xs font-bold transition border uppercase flex items-center shadow-sm"
                            :class="filterType === proto ? getProtocolBadgeColor(proto).replace('text-slate-900', 'text-white border-transparent shadow-lg') : 'bg-slate-800 border-slate-700/50 text-slate-400 hover:text-white hover:border-slate-600'">
                            {{ proto }}
                            <span class="ml-2 bg-black/20 px-1.5 rounded text-[10px]">{{ protocolStats[proto] }}</span>
                        </button>
                    </div>

                    <!-- Country Filter (Dropdown) -->
                    <div v-if="countries.length > 0" class="mb-6 animate-fade-in relative max-w-xs">
                        <select v-model="filterCountry"
                            class="w-full bg-slate-800 border border-slate-700/50 rounded-xl pl-4 pr-10 py-2.5 text-sm text-slate-200 focus:ring-2 focus:ring-indigo-500/50 outline-none appearance-none transition shadow-inner cursor-pointer font-bold">
                            <option value="all">ğŸŒ å…¨çƒæ‰€æœ‰åœ°åŒº ({{ proxiesByType.length }})</option>
                            <option v-for="c in countries" :key="c" :value="c">
                                {{ c }} ({{ countryStats[c] }})
                            </option>
                        </select>
                        <span
                            class="absolute right-3 top-3 text-slate-500 material-icons-round text-sm pointer-events-none">expand_more</span>
                    </div>

                    <!-- Search & Sort Controls -->
                    <div class="flex flex-col md:flex-row gap-4 mb-6">
                        <div class="relative flex-1">
                            <span
                                class="absolute left-3 top-2.5 text-slate-500 material-icons-round text-lg">search</span>
                            <input v-model="searchQuery" type="text" placeholder="æœç´¢èŠ‚ç‚¹ (åç§°/åè®®/åœ°å€)..."
                                class="w-full bg-slate-800 border border-slate-700/50 rounded-xl pl-10 pr-4 py-2.5 text-sm text-slate-200 focus:ring-2 focus:ring-indigo-500/50 outline-none transition shadow-inner">
                        </div>

                        <div class="relative min-w-[160px]">
                            <span
                                class="absolute left-3 top-2.5 text-slate-500 material-icons-round text-lg">sort</span>
                            <select v-model="sortMode"
                                class="w-full bg-slate-800 border border-slate-700/50 rounded-xl pl-10 pr-8 py-2.5 text-sm text-slate-200 focus:ring-2 focus:ring-indigo-500/50 outline-none appearance-none transition shadow-inner cursor-pointer">
                                <option value="latency">ğŸš€ æŒ‰å»¶è¿Ÿæ’åº</option>
                                <option value="purity">ğŸ›¡ï¸ æŒ‰çº¯å‡€åº¦æ’åº</option>
                            </select>
                            <span
                                class="absolute right-3 top-3 text-slate-500 material-icons-round text-sm pointer-events-none">expand_more</span>
                        </div>
                    </div>

                    <div class="flex flex-col md:flex-row justify-between items-end mb-3 px-1 gap-2">
                        <div class="flex items-center space-x-3">
                            <h3 class="text-slate-400 text-sm font-medium">èŠ‚ç‚¹åˆ—è¡¨ ({{ filteredProxies.length }})</h3>

                            <!-- Selection Toolbar -->
                            <div class="flex items-center bg-slate-800 rounded-lg p-1 border border-slate-700/50">
                                <button @click="toggleSelectPage"
                                    class="px-2 py-1 text-xs rounded hover:bg-slate-700 transition flex items-center"
                                    :class="pageSelected ? 'text-indigo-400 font-bold' : 'text-slate-400'">
                                    <span class="material-icons-round text-sm mr-1">{{ pageSelected ? 'check_box' :
                                        'check_box_outline_blank' }}</span>
                                    å…¨é€‰æœ¬é¡µ
                                </button>
                                <div class="w-px h-3 bg-slate-700 mx-1"></div>
                                <button @click="clearSelection" v-if="selectedCount > 0"
                                    class="px-2 py-1 text-xs rounded hover:bg-red-500/20 text-red-400 transition flex items-center">
                                    æ¸…é™¤ ({{ selectedCount }})
                                </button>
                                <!-- Purity Check Button -->
                                <button @click="checkSelectedPurity" v-if="selectedCount > 0" :disabled="purityChecking"
                                    class="px-2 py-1 text-xs rounded hover:bg-teal-500/20 transition flex items-center ml-1"
                                    :class="purityChecking ? 'text-slate-500 cursor-not-allowed' : 'text-teal-400'">
                                    <span class="material-icons-round text-sm mr-1"
                                        :class="purityChecking ? 'animate-spin' : ''">
                                        {{ purityChecking ? 'sync' : 'verified' }}
                                    </span>
                                    {{ purityChecking ? 'æ£€æµ‹ä¸­...' : 'çº¯å‡€åº¦æ£€æŸ¥' }}
                                </button>
                            </div>
                            <!-- Hide Failed Toggle -->
                            <button @click="hideFailed = !hideFailed"
                                class="px-2 py-1 text-xs rounded hover:bg-slate-700 transition flex items-center border border-transparent"
                                :class="hideFailed ? 'text-indigo-400 bg-slate-800 border-indigo-500/30' : 'text-slate-500'">
                                <span class="material-icons-round text-sm mr-1">{{ hideFailed ? 'visibility_off' :
                                    'visibility' }}</span>
                                {{ hideFailed ? 'éšè—è¶…æ—¶' : 'å«è¶…æ—¶' }}
                            </button>
                            <!-- Manual Only Toggle -->
                            <button @click="showManualOnly = !showManualOnly"
                                class="px-2 py-1 text-xs rounded hover:bg-slate-700 transition flex items-center border border-transparent"
                                :class="showManualOnly ? 'text-amber-400 bg-slate-800 border-amber-500/30' : 'text-slate-500'">
                                <span class="material-icons-round text-sm mr-1">{{ showManualOnly ? 'bookmark' :
                                    'bookmark_border' }}</span>
                                æ‰‹åŠ¨æ·»åŠ 
                                <span v-if="manualProxies.length > 0"
                                    class="ml-1 bg-amber-500/20 text-amber-400 px-1 rounded text-[10px]">{{
                                    manualProxies.length }}</span>
                            </button>
                            <!-- Forum (Linux.do) Only Toggle -->
                            <button @click="showForumOnly = !showForumOnly"
                                class="px-2 py-1 text-xs rounded hover:bg-slate-700 transition flex items-center border border-transparent"
                                :class="showForumOnly ? 'text-purple-400 bg-slate-800 border-purple-500/30' : 'text-slate-500'">
                                <span class="material-icons-round text-sm mr-1">{{ showForumOnly ? 'forum' :
                                    'chat_bubble_outline' }}</span>
                                è®ºå›
                                <span v-if="forumProxiesCount > 0"
                                    class="ml-1 bg-purple-500/20 text-purple-400 px-1 rounded text-[10px]">{{
                                    forumProxiesCount }}</span>
                            </button>
                            <!-- Telegram Only Toggle -->
                            <button @click="showTelegramOnly = !showTelegramOnly"
                                class="px-2 py-1 text-xs rounded hover:bg-slate-700 transition flex items-center border border-transparent"
                                :class="showTelegramOnly ? 'text-blue-400 bg-slate-800 border-blue-500/30' : 'text-slate-500'">
                                <span class="material-icons-round text-sm mr-1">send</span>
                                TGé¢‘é“
                                <span v-if="telegramProxiesCount > 0"
                                    class="ml-1 bg-blue-500/20 text-blue-400 px-1 rounded text-[10px]">{{
                                    telegramProxiesCount }}</span>
                            </button>
                        </div>

                        <div v-if="autoCheckCount > 0" class="text-xs text-indigo-400 animate-pulse flex items-center">
                            <span class="material-icons-round text-sm mr-1 animate-spin">sync</span>
                            è‡ªåŠ¨æ£€æµ‹ä¸­: å‰©ä½™ {{ autoCheckCount }} ä¸ª
                        </div>
                    </div>

                    <transition-group name="list" tag="div"
                        class="grid grid-cols-1 md:grid-cols-2 gap-4 max-h-[calc(100vh-280px)] overflow-y-auto custom-scrollbar pr-2 content-start">
                        <div v-for="node in filteredProxies" :key="node.id"
                            class="glass-panel p-4 rounded-xl hover:bg-slate-800/80 transition group relative overflow-hidden border-l-4"
                            :class="getProtocolColor(node.type)">
                            <div class="flex justify-between items-start mb-2">
                                <div class="flex items-center space-x-2 overflow-hidden">
                                    <!-- Checkbox -->
                                    <div @click.stop="toggleSelection(node.id)"
                                        class="cursor-pointer text-slate-500 hover:text-indigo-400 transition mr-1">
                                        <span class="material-icons-round text-lg">{{ selectedIds.has(node.id) ?
                                            'check_box' : 'check_box_outline_blank' }}</span>
                                    </div>

                                    <span class="text-xs font-bold px-1.5 py-0.5 rounded text-slate-900 uppercase"
                                        :class="getProtocolBadgeColor(node.type)">
                                        {{ node.type }}
                                    </span>
                                    <!-- æ‰‹åŠ¨æ·»åŠ æ ‡è®° -->
                                    <span v-if="node.isManual"
                                        class="text-[10px] px-1 py-0.5 rounded bg-amber-500/20 text-amber-400 font-medium">æ‰‹åŠ¨</span>
                                    <!-- è®ºå›å¯¼å…¥æ ‡è®° -->
                                    <span v-if="node.isFromForum"
                                        class="text-[10px] px-1 py-0.5 rounded bg-purple-500/20 text-purple-400 font-medium flex items-center">
                                        <span class="material-icons-round text-[10px] mr-0.5">forum</span>
                                        {{ node.forumSource || 'è®ºå›' }}
                                    </span>
                                    <!-- Telegram å¯¼å…¥æ ‡è®° -->
                                    <span v-if="node.isFromTelegram"
                                        class="text-[10px] px-1 py-0.5 rounded bg-blue-500/20 text-blue-400 font-medium flex items-center">
                                        <span class="material-icons-round text-[10px] mr-0.5">send</span>
                                        TG
                                    </span>
                                    <h4 class="font-medium text-slate-200 truncate" :title="node.name">{{ node.name }}
                                    </h4>
                                </div>
                                <div class="flex items-center space-x-1">
                                    <button @click="checkNodePurity(node)"
                                        class="text-slate-500 hover:text-blue-400 p-1 transition" title="æ£€æµ‹çº¯å‡€åº¦"
                                        :disabled="node.checking">
                                        <span class="material-icons-round text-sm"
                                            :class="{'animate-spin': node.checking}">shield</span>
                                    </button>
                                    <button @click="node.isManual ? deleteManualProxy(node) : deleteProxy(node.id)"
                                        class="text-slate-600 hover:text-red-400 p-1 transition" title="åˆ é™¤">
                                        <span class="material-icons-round text-sm">delete</span>
                                    </button>
                                </div>
                            </div>

                            <div class="grid grid-cols-2 gap-2 text-xs text-slate-400 mb-3">
                                <div class="truncate" title="åœ°å€">{{ node.server }}:{{ node.port }}</div>
                                <div class="truncate" title="å»¶è¿Ÿ">
                                    <!-- Local Latency (Priority) -->
                                    <span v-if="typeof node.localLatency !== 'undefined'" :class="{
                                        'text-red-500 font-bold': node.localLatency === -1,
                                        'text-emerald-400': node.localLatency >= 0 && node.localLatency < 200,
                                        'text-yellow-400': node.localLatency >= 200 && node.localLatency < 500,
                                        'text-orange-400': node.localLatency >= 500
                                    }">
                                        <span class="material-icons-round text-[10px] align-middle mr-1">{{
                                            node.localLatency === -1 ? 'error' : 'network_check' }}</span>
                                        {{ node.localLatency === -1 ? 'è¶…æ—¶' : node.localLatency + ' ms (æœ¬åœ°)' }}
                                    </span>
                                    <!-- Imported Latency (Fallback) -->
                                    <span v-else-if="node.latency" :class="{
                                        'text-emerald-400': node.latency < 100,
                                        'text-yellow-400': node.latency >= 100 && node.latency < 200,
                                        'text-orange-400': node.latency >= 200
                                    }">
                                        <span class="material-icons-round text-[10px] align-middle mr-1">speed</span>
                                        {{ node.latency }} ms
                                    </span>
                                </div>
                                <div class="truncate col-span-2 opacity-50 font-mono" title="åŠ å¯†/åè®® ID">
                                    {{ node.uuid || node.password || 'Data ' + node.id }}
                                </div>
                            </div>

                            <!-- Purity/Risk Info -->
                            <div v-if="node.failedCheck"
                                class="mt-2 pt-2 border-t border-slate-700/50 text-xs flex items-center justify-between text-red-400 animate-fade-in">
                                <span class="flex items-center">
                                    <span class="material-icons-round text-sm mr-1">error</span>
                                    çº¯å‡€åº¦æ£€æµ‹å¤±è´¥
                                </span>
                            </div>

                            <div v-if="node.purity"
                                class="mt-2 pt-2 border-t border-slate-700/50 text-xs flex items-center justify-between animate-fade-in">
                                <div class="flex items-center text-slate-300">
                                    <span class="mr-2 font-bold">{{ node.purity.countryCode }}</span>
                                    <span class="truncate max-w-[80px]" :title="node.purity.isp">{{ node.purity.isp
                                        }}</span>
                                </div>
                                <div class="flex items-center space-x-2">
                                    <span class="px-1.5 py-0.5 rounded font-bold transition-colors" :class="{
                                            'bg-emerald-500/20 text-emerald-400': node.purityScore >= 80,
                                            'bg-yellow-500/20 text-yellow-400': node.purityScore >= 60 && node.purityScore < 80,
                                            'bg-red-500/20 text-red-400': node.purityScore < 60
                                        }">
                                        {{ (node.purityScore !== undefined ? node.purityScore : (node.purity.hosting ?
                                        50 : 90)) }}åˆ†
                                    </span>
                                </div>
                            </div>
                        </div>
                    </transition-group>

                    <!-- Pagination Controls -->
                    <div v-if="totalPages > 1" class="flex justify-center items-center space-x-4 mt-6 animate-fade-in">
                        <button @click="prevPage" :disabled="currentPage === 1"
                            class="px-4 py-2 rounded-lg bg-slate-800 hover:bg-slate-700 disabled:opacity-50 disabled:cursor-not-allowed transition text-sm flex items-center">
                            <span class="material-icons-round mr-1 text-base">chevron_left</span>
                            ä¸Šä¸€é¡µ
                        </button>

                        <span class="text-slate-400 text-sm font-mono">
                            {{ currentPage }} / {{ totalPages }}
                        </span>

                        <!-- Page Size Selector -->
                        <div class="relative">
                            <select v-model="pageSize" @change="currentPage = 1"
                                class="bg-slate-800 border-none text-slate-400 text-xs rounded px-2 py-1 outline-none cursor-pointer hover:bg-slate-700 transition appearance-none pr-6">
                                <option :value="50">50 æ¡/é¡µ</option>
                                <option :value="100">100 æ¡/é¡µ</option>
                                <option :value="200">200 æ¡/é¡µ</option>
                                <option :value="500">500 æ¡/é¡µ</option>
                            </select>
                            <span
                                class="absolute right-1 top-1.5 text-slate-500 material-icons-round text-xs pointer-events-none">expand_more</span>
                        </div>

                        <button @click="nextPage" :disabled="currentPage === totalPages"
                            class="px-4 py-2 rounded-lg bg-slate-800 hover:bg-slate-700 disabled:opacity-50 disabled:cursor-not-allowed transition text-sm flex items-center">
                            ä¸‹ä¸€é¡µ
                            <span class="material-icons-round ml-1 text-base">chevron_right</span>
                        </button>
                    </div>
                </div>
            </div>
        </main>

        <footer class="mt-12 border-t border-slate-800 pt-6 text-center text-slate-500 text-sm">
            <p>&copy; 2026 Antigravity. All rights reserved.</p>
        </footer>

        <!-- Export Modal -->
        <div v-if="showExportModal" class="fixed inset-0 z-50 flex items-center justify-center p-4">
            <div class="absolute inset-0 bg-black/60 backdrop-blur-sm" @click="showExportModal = false"></div>
            <div class="glass-panel w-full max-w-md rounded-2xl p-6 relative z-10 animate-fade-in-up">
                <h3 class="text-xl font-bold text-white mb-2">å¯¼å‡ºé…ç½®</h3>
                <p class="text-sm text-slate-400 mb-4">
                    {{ selectedCount > 0 ? `å°†å¯¼å‡ºå·²é€‰ä¸­çš„ ${selectedCount} ä¸ªèŠ‚ç‚¹` : `å°†å¯¼å‡ºå½“å‰åˆ—è¡¨æ‰€æœ‰ ${proxies.length} ä¸ªèŠ‚ç‚¹` }}
                </p>
                <div class="space-y-3">
                    <button @click="exportConfig('clash')"
                        class="w-full p-4 rounded-xl bg-slate-800 hover:bg-slate-700 border border-slate-700/50 flex items-center justify-between group transition">
                        <div class="flex items-center">
                            <span class="material-icons-round text-blue-400 mr-3 text-3xl">api</span>
                            <div class="text-left">
                                <div class="text-white font-medium">Clash é…ç½® (YAML)</div>
                                <div class="text-xs text-slate-400">æ ‡å‡† Clash å®¢æˆ·ç«¯æ ¼å¼</div>
                            </div>
                        </div>
                        <span class="material-icons-round text-slate-500 group-hover:text-white">arrow_forward</span>
                    </button>

                    <button @click="exportConfig('singbox')"
                        class="w-full p-4 rounded-xl bg-slate-800 hover:bg-slate-700 border border-slate-700/50 flex items-center justify-between group transition">
                        <div class="flex items-center">
                            <span class="material-icons-round text-pink-400 mr-3 text-3xl">dns</span>
                            <div class="text-left">
                                <div class="text-white font-medium">Sing-box é…ç½® (JSON)</div>
                                <div class="text-xs text-slate-400">ç°ä»£ä»£ç†å¹³å°æ ¼å¼</div>
                            </div>
                        </div>
                        <span class="material-icons-round text-slate-500 group-hover:text-white">arrow_forward</span>
                    </button>

                    <button @click="exportConfig('base64')"
                        class="w-full p-4 rounded-xl bg-slate-800 hover:bg-slate-700 border border-slate-700/50 flex items-center justify-between group transition">
                        <div class="flex items-center">
                            <span class="material-icons-round text-emerald-400 mr-3 text-3xl">code</span>
                            <div class="text-left">
                                <div class="text-white font-medium">Base64 è®¢é˜…é“¾æ¥</div>
                                <div class="text-xs text-slate-400">é€šç”¨è®¢é˜…æ ¼å¼</div>
                            </div>
                        </div>
                        <span class="material-icons-round text-slate-500 group-hover:text-white">arrow_forward</span>
                    </button>
                </div>
                <button @click="showExportModal = false"
                    class="mt-6 w-full py-2 text-slate-400 hover:text-white text-sm">å–æ¶ˆ</button>
            </div>
        </div>

        <!-- Log Terminal Modal -->
        <div v-show="showLogModal" class="fixed inset-0 z-50 flex items-center justify-center pointer-events-none">
            <!-- Overlay -->
            <div class="absolute inset-0 bg-black/30 backdrop-blur-sm transition-opacity pointer-events-auto"
                @click="!cloudLoading && (showLogModal = false)"></div>

            <!-- Draggable Window -->
            <div ref="logWindowEl" :style="modalStyle"
                class="absolute bg-slate-900/90 backdrop-blur-xl w-full max-w-3xl h-[65vh] rounded-xl shadow-2xl z-50 flex flex-col border border-slate-600/50 animate-fade-in-up overflow-hidden pointer-events-auto">
                <!-- Mac-style Header with Drag Handle -->
                <div @mousedown="startDrag"
                    class="bg-white/5 px-4 py-3 flex items-center justify-between border-b border-white/10 cursor-grab active:cursor-grabbing select-none">
                    <div class="flex items-center space-x-2">
                        <div @click.stop="!cloudLoading && (showLogModal = false)"
                            class="w-3 h-3 rounded-full bg-red-500 hover:bg-red-600 cursor-pointer flex items-center justify-center group">
                            <span
                                class="material-icons-round text-[8px] text-black opacity-0 group-hover:opacity-100">close</span>
                        </div>
                        <div class="w-3 h-3 rounded-full bg-yellow-500"></div>
                        <div class="w-3 h-3 rounded-full bg-green-500"></div>
                    </div>
                    <div class="text-xs font-mono text-slate-400">antigravity-crawler â€” -zsh â€” 80x24</div>
                    <div class="w-10"></div>
                </div>

                <!-- Terminal Content -->
                <div ref="logWindowRef"
                    class="flex-1 p-4 overflow-y-auto font-mono text-xs space-y-1 custom-scrollbar text-slate-300">
                    <div v-if="serverLogs.length === 0" class="text-slate-500 italic">Waiting for logs...</div>
                    <div v-for="(log, idx) in serverLogs" :key="idx" class="break-words">
                        <span class="text-slate-600 mr-2">[{{ log.timestamp }}]</span>
                        <span :class="{
                            'text-emerald-400': log.type === 'success',
                            'text-red-400': log.type === 'error',
                            'text-blue-400': log.type === 'info', 
                            'text-yellow-400': log.type === 'warning',
                            'text-slate-300': !log.type || log.type === 'normal'
                        }">{{ log.msg }}</span>
                    </div>
                    <div v-if="cloudLoading" class="animate-pulse text-indigo-400 mt-2">â–‹</div>
                </div>

                <!-- Footer Stats -->
                <div
                    class="bg-black/40 px-4 py-2 text-xs text-slate-500 border-t border-white/10 flex justify-between items-center font-mono">
                    <div class="flex space-x-4">
                        <span class="text-slate-500">Task Scanned: <span class="text-white">{{ serverStats.total
                                }}</span></span>
                        <span v-if="serverStats.active > 0" class="text-emerald-500">Valid: {{ serverStats.active
                            }}</span>
                    </div>

                    <span v-if="cloudLoading" class="flex items-center text-blue-400">
                        <span class="material-icons-round text-xs animate-spin mr-1">sync</span>
                        Running...
                    </span>
                    <span v-else class="text-emerald-400">Done</span>
                </div>
            </div>
        </div>

        <!-- Clear Confirmation Modal -->
        <div v-if="showClearModal" class="fixed inset-0 z-50 flex items-center justify-center p-4">
            <div class="absolute inset-0 bg-black/60 backdrop-blur-sm"></div>
            <div
                class="glass-panel w-full max-w-sm rounded-2xl p-6 relative z-10 animate-fade-in-up border border-red-500/30">
                <div class="flex items-center mb-4 text-red-400">
                    <span class="material-icons-round text-3xl mr-2">warning</span>
                    <h3 class="text-xl font-bold text-white">ç¡®è®¤æ¸…ç©ºï¼Ÿ</h3>
                </div>
                <p class="text-sm text-slate-300 mb-6 leading-relaxed">
                    æ‚¨å³å°†æ¸…ç©ºæ‰€æœ‰ <span class="font-bold text-white">{{ proxies.length }}</span> ä¸ªèŠ‚ç‚¹ã€‚<br>
                    æ­¤æ“ä½œ<span class="text-red-400 font-bold">æ— æ³•æ’¤é”€</span>ï¼Œæ‚¨ç¡®å®šè¦ç»§ç»­å—ï¼Ÿ
                </p>
                <div class="space-y-3">
                    <button @click="confirmClear"
                        class="w-full py-3 rounded-xl bg-red-600 hover:bg-red-500 text-white font-bold shadow-lg shadow-red-600/20 transition active:scale-95">
                        ç¡®è®¤æ¸…ç©º
                    </button>
                    <button @click="showClearModal = false"
                        class="w-full py-3 rounded-xl bg-slate-800 hover:bg-slate-700 text-slate-300 transition text-sm">
                        å–æ¶ˆ
                    </button>
                </div>
            </div>
        </div>

        <!-- Toast -->
        <transition name="fade">
            <div v-if="toastMsg" class="fixed bottom-6 left-1/2 transform -translate-x-1/2 z-50">
                <div
                    class="bg-indigo-600 text-white px-6 py-3 rounded-full shadow-lg shadow-indigo-500/30 font-medium flex items-center text-sm">
                    <span class="material-icons-round mr-2 text-base">check_circle</span>
                    {{ toastMsg }}
                </div>
            </div>
        </transition>
    </div>


    <!-- Logic -->
    <script>
        const { createApp, ref, computed, onMounted, watch } = Vue;

        createApp({
            setup() {
                const inputUrl = ref('');
                const rawContent = ref('');
                const proxies = ref([]);
                const loading = ref(false);
                const errorMsg = ref('');
                const searchQuery = ref('');
                const filterType = ref('all'); // all, vmess, ss, etc
                const filterCountry = ref('all');
                const sortMode = ref('latency'); // latency, purity, local
                const hideFailed = ref(false);
                const showManualOnly = ref(false); // åªæ˜¾ç¤ºæ‰‹åŠ¨æ·»åŠ çš„èŠ‚ç‚¹
                const showForumOnly = ref(false); // åªæ˜¾ç¤ºè®ºå›å¯¼å…¥çš„èŠ‚ç‚¹
                const showTelegramOnly = ref(false); // åªæ˜¾ç¤º Telegram å¯¼å…¥çš„èŠ‚ç‚¹
                const manualProxies = ref([]);	// æ‰‹åŠ¨æ·»åŠ çš„èŠ‚ç‚¹åˆ—è¡¨

                const isLocalChecking = ref(false);
                const localCheckProgress = ref('');
                const linuxDoLoading = ref(false); // Linux.do å¯¼å…¥åŠ è½½çŠ¶æ€

                // Telegram é¢‘é“æŠ“å–çŠ¶æ€
                const telegramLoading = ref(false);
                const telegramTaskRunning = ref(false);
                const telegramStatus = ref({
                    isRunning: false,
                    isScheduled: false,
                    lastRun: null,
                    nextRun: null,
                    intervalMinutes: 30,
                    stats: {},
                    currentTask: '',
                    progressLog: []
                });
                let telegramStatusPoller = null;

                const showImportParams = ref(false);
                const showExportModal = ref(false);
                const showClearModal = ref(false);
                const showLogModal = ref(false); // Controls visibility of log window

                const serverLogs = ref([]); // Stores logs from server
                const logWindowRef = ref(null);
                const logWindowEl = ref(null);

                // --- Drag Logic ---
                const modalStyle = ref({
                    top: '15%',
                    left: '50%',
                    transform: 'translateX(-50%)',
                    margin: '0'
                });

                let isDragging = false;
                let dragOffset = { x: 0, y: 0 };

                const startDrag = (e) => {
                    if (!logWindowEl.value) return;
                    isDragging = true;
                    const rect = logWindowEl.value.getBoundingClientRect();
                    dragOffset.x = e.clientX - rect.left;
                    dragOffset.y = e.clientY - rect.top;

                    // Convert to absolute pixels to remove transform dependency during drag
                    modalStyle.value = {
                        top: `${rect.top}px`,
                        left: `${rect.left}px`,
                        width: `${rect.width}px`, // maintain width
                        transform: 'none',
                        margin: '0'
                    };

                    window.addEventListener('mousemove', onDrag);
                    window.addEventListener('mouseup', stopDrag);
                };

                const onDrag = (e) => {
                    if (!isDragging) return;
                    e.preventDefault();
                    const x = e.clientX - dragOffset.x;
                    const y = e.clientY - dragOffset.y;
                    modalStyle.value = {
                        ...modalStyle.value,
                        top: `${y}px`,
                        left: `${x}px`
                    };
                };

                const stopDrag = () => {
                    isDragging = false;
                    window.removeEventListener('mousemove', onDrag);
                    window.removeEventListener('mouseup', stopDrag);
                };

                // Auto-scroll logs
                watch(serverLogs, () => {
                    if (showLogModal.value && logWindowRef.value) {
                        setTimeout(() => {
                            logWindowRef.value.scrollTop = logWindowRef.value.scrollHeight;
                        }, 50);
                    }
                }, { deep: true });




                // Selection
                const selectedIds = ref(new Set());

                const toggleSelection = (id) => {
                    const s = new Set(selectedIds.value);
                    if (s.has(id)) s.delete(id);
                    else s.add(id);
                    selectedIds.value = s;
                };

                const clearSelection = () => selectedIds.value = new Set();

                const selectedCount = computed(() => selectedIds.value.size);

                // çº¯å‡€åº¦æ£€æŸ¥çŠ¶æ€
                const purityChecking = ref(false);

                // æ‰‹åŠ¨æ£€æŸ¥é€‰ä¸­èŠ‚ç‚¹çš„çº¯å‡€åº¦
                const checkSelectedPurity = async () => {
                    if (purityChecking.value || selectedCount.value === 0) return;

                    purityChecking.value = true;
                    const selected = proxies.value.filter(p => selectedIds.value.has(p.id));

                    try {
                        showToast(`æ­£åœ¨æ£€æŸ¥ ${selected.length} ä¸ªèŠ‚ç‚¹çš„çº¯å‡€åº¦...`);

                        const res = await fetch('/api/check_purity', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ proxies: selected })
                        });

                        const data = await res.json();

                        if (data.success && data.results) {
                            // æ›´æ–°èŠ‚ç‚¹çš„çº¯å‡€åº¦ä¿¡æ¯
                            const resultMap = new Map(data.results.map(r => [r.id, r]));

                            proxies.value = proxies.value.map(p => {
                                if (resultMap.has(p.id)) {
                                    const result = resultMap.get(p.id);
                                    return {
                                        ...p,
                                        purityScore: result.purityScore,
                                        purityInfo: result.purityInfo,
                                        purity: {
                                            countryCode: result.purityInfo?.country || result.purityInfo?.countryCode,
                                            isp: result.purityInfo?.isp || '',
                                            hosting: result.purityInfo?.hosting || false
                                        }
                                    };
                                }
                                return p;
                            });

                            showToast(`çº¯å‡€åº¦æ£€æŸ¥å®Œæˆï¼Œå·²æ›´æ–° ${data.checked} ä¸ªèŠ‚ç‚¹`);
                        } else {
                            showToast(`æ£€æŸ¥å¤±è´¥: ${data.error || 'æœªçŸ¥é”™è¯¯'}`);
                        }
                    } catch (e) {
                        console.error('çº¯å‡€åº¦æ£€æŸ¥é”™è¯¯:', e);
                        showToast(`æ£€æŸ¥å¤±è´¥: ${e.message}`);
                    } finally {
                        purityChecking.value = false;
                    }
                };

                const currentPage = ref(1);
                const pageSize = ref(50); // Render 50 items per page

                // Persistence - ä»æœåŠ¡å™¨åŠ è½½æ•°æ®
                const loadProxies = async () => {
                    try {
                        // ä»æœåŠ¡å™¨åŠ è½½äº‘ç«¯æŠ“å–çš„èŠ‚ç‚¹
                        const res = await fetch('/api/proxies');
                        const cloudProxies = await res.json();

                        // ä»æœåŠ¡å™¨åŠ è½½æ‰‹åŠ¨æ·»åŠ çš„èŠ‚ç‚¹
                        const manualRes = await fetch('/api/manual_proxies');
                        const manualData = await manualRes.json();
                        manualProxies.value = manualData;

                        // åˆå¹¶èŠ‚ç‚¹ï¼ˆå»é‡ï¼‰
                        const allProxies = [...cloudProxies];
                        const existingRaw = new Set(allProxies.map(p => p.raw));

                        for (const mp of manualData) {
                            if (!existingRaw.has(mp.raw)) {
                                allProxies.push(mp);
                            }
                        }

                        // å°†åç«¯çš„ purityInfo æ˜ å°„åˆ°å‰ç«¯æ˜¾ç¤ºéœ€è¦çš„ purity å­—æ®µ
                        allProxies.forEach(p => {
                            if (p.purityInfo && !p.purity) {
                                p.purity = {
                                    countryCode: p.purityInfo.country || p.purityInfo.countryCode,
                                    isp: p.purityInfo.isp || '',
                                    hosting: p.purityInfo.hosting || false
                                };
                            }
                        });

                        proxies.value = allProxies;
                        console.log(`Loaded ${cloudProxies.length} cloud + ${manualData.length} manual proxies from server`);
                    } catch (e) {
                        console.error('Failed to load proxies from server:', e);
                    }
                };

                const saveProxies = () => {
                    // ä¸å†ä½¿ç”¨ localStorageï¼Œæ•°æ®å·²ä¿å­˜åœ¨æœåŠ¡å™¨
                    console.log('Proxies synced to server');
                };

                // Watchers - ä¸å†ä¿å­˜åˆ° localStorage
                watch(proxies, () => {
                    // æ•°æ®å˜åŒ–ç”±å„ä¸ªæ“ä½œï¼ˆæ‰‹åŠ¨æ·»åŠ ã€åˆ é™¤ç­‰ï¼‰è‡ªè¡Œå¤„ç†ä¿å­˜
                    // æ­¤å¤„ä¸åšä»»ä½•ä¿å­˜æ“ä½œ
                }, { deep: true });

                // Reset page on search or sort change
                watch([searchQuery, sortMode, filterType, filterCountry], () => currentPage.value = 1);

                // --- Computed ---
                const getCountry = (node) => {
                    if (node.purity && node.purity.countryCode) return node.purity.countryCode;
                    // Heuristic: Check for _CN_, _US_, etc in name
                    const match = node.name.match(/_([A-Z]{2})_/);
                    if (match) return match[1];
                    return 'Other';
                };

                // --- Dynamic Stats Logic ---

                // 1. Base Context: Applies Search & HideFailed (Shared by all views)
                // This represents the "User's current universe of interesting nodes"
                const baseContextProxies = computed(() => {
                    let res = proxies.value;

                    // æ‰‹åŠ¨æ·»åŠ è¿‡æ»¤
                    if (showManualOnly.value) {
                        const manualIds = new Set(manualProxies.value.map(p => p.id));
                        res = res.filter(p => p.isManual || manualIds.has(p.id));
                    }

                    // è®ºå›æ¥æºè¿‡æ»¤
                    if (showForumOnly.value) {
                        res = res.filter(p => p.isFromForum === true);
                    }

                    // Telegram æ¥æºè¿‡æ»¤
                    if (showTelegramOnly.value) {
                        res = res.filter(p => p.isFromTelegram === true);
                    }

                    if (searchQuery.value) {
                        const q = searchQuery.value.toLowerCase();
                        res = res.filter(p =>
                            p.name.toLowerCase().includes(q) ||
                            p.server.toLowerCase().includes(q) ||
                            p.type.toLowerCase().includes(q)
                        );
                    }

                    if (hideFailed.value) {
                        res = res.filter(p => {
                            if (p.localLatency === undefined) return true;
                            return p.localLatency !== -1 && p.localLatency !== 99999;
                        });
                    }
                    return res;
                });

                // 2. For Country Dropdown & Lists:
                // Depends on Base + Protocol Selection (but IGNORES Country Selection)
                const proxiesForCountryStats = computed(() => {
                    if (filterType.value === 'all') return baseContextProxies.value;
                    return baseContextProxies.value.filter(p => p.type === filterType.value);
                });

                // Used by Country Dropdown
                const proxiesByType = proxiesForCountryStats;

                // 3. For Protocol Tabs:
                // Depends on Base + Country Selection (but IGNORES Protocol Selection)
                const proxiesForProtocolStats = computed(() => {
                    if (filterCountry.value === 'all') return baseContextProxies.value;
                    return baseContextProxies.value.filter(p => getCountry(p) === filterCountry.value);
                });

                // 4. Total Visible Count (for "All Protocols" tab)
                const totalVisibleCount = computed(() => proxiesForProtocolStats.value.length);

                const countries = computed(() => {
                    const s = new Set(proxiesByType.value.map(p => getCountry(p)));
                    return [...s].filter(c => c !== 'Other').sort();
                });

                const countryStats = computed(() => {
                    const stats = {};
                    proxiesByType.value.forEach(p => {
                        const c = getCountry(p);
                        stats[c] = (stats[c] || 0) + 1;
                    });
                    return stats;
                });

                const protocols = computed(() => {
                    return [...new Set(proxies.value.map(p => p.type))];
                });

                // è®ºå›å¯¼å…¥èŠ‚ç‚¹è®¡æ•°
                const forumProxiesCount = computed(() => {
                    return proxies.value.filter(p => p.isFromForum === true).length;
                });

                // Telegram å¯¼å…¥èŠ‚ç‚¹è®¡æ•°
                const telegramProxiesCount = computed(() => {
                    return proxies.value.filter(p => p.isFromTelegram === true).length;
                });

                const protocolStats = computed(() => {
                    const stats = {};
                    // Init with 0
                    protocols.value.forEach(p => stats[p] = 0);
                    // Count based on filtered context
                    proxiesForProtocolStats.value.forEach(p => {
                        stats[p.type] = (stats[p.type] || 0) + 1;
                    });
                    return stats;
                });

                const allFilteredProxies = computed(() => {
                    // Start from Base Context
                    let res = baseContextProxies.value;

                    // Apply Protocol Filter
                    if (filterType.value !== 'all') {
                        res = res.filter(p => p.type === filterType.value);
                    }

                    // Apply Country Filter
                    if (filterCountry.value !== 'all') {
                        res = res.filter(p => getCountry(p) === filterCountry.value);
                    }


                    // hideFailed is already applied in baseContextProxies


                    // Sorting
                    return res.sort((a, b) => {
                        const latA = (typeof a.latency === 'number') ? a.latency : 99999;
                        const latB = (typeof b.latency === 'number') ? b.latency : 99999;

                        if (sortMode.value === 'purity') {
                            const scoreA = (typeof a.purityScore === 'number') ? a.purityScore : -1;
                            const scoreB = (typeof b.purityScore === 'number') ? b.purityScore : -1;

                            if (scoreA !== scoreB) {
                                return scoreB - scoreA; // High score first
                            }
                            // Fallback to latency
                            return latA - latB;
                        }

                        // Sort by Local Latency (New)
                        if (sortMode.value === 'local') {
                            // Fix: Treat -1 (timeout) as Infinity (bottom), and undefined as Infinity
                            const getVal = (v) => (typeof v === 'number' && v >= 0) ? v : 999999;
                            return getVal(a.localLatency) - getVal(b.localLatency);
                        }

                        // Default: Latency
                        return latA - latB;
                    });
                });

                const totalPages = computed(() => Math.ceil(allFilteredProxies.value.length / pageSize.value));

                const filteredProxies = computed(() => {
                    const start = (currentPage.value - 1) * pageSize.value;
                    const end = start + pageSize.value;
                    return allFilteredProxies.value.slice(start, end);
                });

                const pageSelected = computed(() => {
                    if (filteredProxies.value.length === 0) return false;
                    return filteredProxies.value.every(p => selectedIds.value.has(p.id));
                });

                const toggleSelectPage = () => {
                    const s = new Set(selectedIds.value);
                    const allInPage = filteredProxies.value.every(p => s.has(p.id));

                    if (allInPage) {
                        filteredProxies.value.forEach(p => s.delete(p.id));
                    } else {
                        filteredProxies.value.forEach(p => s.add(p.id));
                    }
                    selectedIds.value = s;
                };

                const nextPage = () => { if (currentPage.value < totalPages.value) currentPage.value++; };
                const prevPage = () => { if (currentPage.value > 1) currentPage.value--; };

                const getProtocolColor = (type) => {
                    switch (type) {
                        case 'vmess': return 'border-indigo-500';
                        case 'vless': return 'border-blue-500';
                        case 'ss': return 'border-emerald-500';
                        case 'trojan': return 'border-pink-500';
                        case 'hysteria2': return 'border-amber-500';
                        default: return 'border-slate-500';
                    }
                };
                const getProtocolBadgeColor = (type) => {
                    switch (type) {
                        case 'vmess': return 'bg-indigo-400';
                        case 'vless': return 'bg-blue-400';
                        case 'ss': return 'bg-emerald-400';
                        case 'trojan': return 'bg-pink-400';
                        case 'hysteria2': return 'bg-amber-400';
                        default: return 'bg-slate-400';
                    }
                };

                // --- Parsing Logic ---
                const decodeBase64 = (str) => {
                    try {
                        return decodeURIComponent(escape(atob(str.replace(/-/g, "+").replace(/_/g, "/"))));
                    } catch (e) {
                        return atob(str);
                    }
                };

                // Helper to parse query string from vmess/vless/trojan raw links if needed
                // But mostly standard is: protocol://uuid@host:port?params#name
                const parseStandardLink = (link, type) => {
                    try {
                        const url = new URL(link);
                        const params = Object.fromEntries(url.searchParams);
                        // Determine TLS status
                        let isTls = false;
                        if (type === 'trojan' || type === 'hysteria2') isTls = true;
                        if (params.security === 'tls' || params.security === 'reality' || params.type === 'grpc') isTls = true;
                        if (type === 'ss') isTls = false; // SS usually no TLS unless plugin

                        const network = params.type || 'tcp';

                        const proxy = {
                            id: Math.random().toString(36).substr(2, 9),
                            name: decodeURIComponent(url.hash.slice(1)) || type + ' Node',
                            type: type,
                            server: url.hostname,
                            port: parseInt(url.port, 10) || 443,
                            uuid: type === 'vless' ? url.username : undefined,
                            password: type === 'trojan' || type === 'hysteria2' ? url.username : undefined,
                            raw: link,
                            tls: isTls,
                            'skip-cert-verify': true,
                            network: network,
                            servername: params.sni || params.host,
                            flow: params.flow
                        };

                        // Reality é…ç½®
                        if (params.security === 'reality') {
                            proxy['reality-opts'] = {
                                'public-key': params.pbk,
                                'short-id': params.sid
                            };
                            proxy['client-fingerprint'] = params.fp || 'chrome';
                        }

                        // WebSocket ä¼ è¾“é…ç½®
                        if (network === 'ws') {
                            proxy['ws-opts'] = {
                                path: params.path || '/',
                                headers: params.host ? { Host: params.host } : undefined
                            };
                        }

                        // gRPC ä¼ è¾“é…ç½®
                        if (network === 'grpc') {
                            proxy['grpc-opts'] = {
                                'grpc-service-name': params.serviceName || params.service || 'grpc'
                            };
                        }

                        // HTTP/2 ä¼ è¾“é…ç½®
                        if (network === 'h2') {
                            proxy['h2-opts'] = {
                                host: params.host ? [params.host] : undefined,
                                path: params.path || '/'
                            };
                        }

                        return proxy;
                    } catch (e) { return null; }
                };

                const parseVmess = (link) => {
                    // Try VMess JSON format (vmess://base64-json)
                    if (!link.includes('@')) {
                        try {
                            const b64 = link.replace('vmess://', '');
                            const json = JSON.parse(decodeBase64(b64));
                            const proxy = {
                                id: Math.random().toString(36).substr(2, 9),
                                name: json.ps || 'VMess Node',
                                type: 'vmess',
                                server: json.add,
                                port: parseInt(json.port, 10) || 443,
                                raw: link,
                                uuid: json.id,
                                alterId: parseInt(json.aid, 10) || 0,
                                cipher: json.scy || 'auto',
                                network: json.net || 'tcp',
                                tls: json.tls === 'tls',
                                'skip-cert-verify': true,
                                servername: json.sni || json.host
                            };

                            // æ·»åŠ  WebSocket ä¼ è¾“é…ç½®
                            if (json.net === 'ws') {
                                proxy['ws-opts'] = {
                                    path: json.path || '/',
                                    headers: json.host ? { Host: json.host } : undefined
                                };
                            }

                            // æ·»åŠ  gRPC ä¼ è¾“é…ç½®
                            if (json.net === 'grpc') {
                                proxy['grpc-opts'] = {
                                    'grpc-service-name': json.path || 'grpc'
                                };
                            }

                            // æ·»åŠ  HTTP/2 ä¼ è¾“é…ç½®
                            if (json.net === 'h2') {
                                proxy['h2-opts'] = {
                                    host: json.host ? [json.host] : undefined,
                                    path: json.path || '/'
                                };
                            }

                            return proxy;
                        } catch (e) { return null; }
                    }
                    // Fallback to standard link parsing if vmess used that way (rare but possible)
                    return parseStandardLink(link, 'vmess');
                };

                const parseContent = async () => {
                    loading.value = true;
                    errorMsg.value = '';
                    let content = rawContent.value;

                    // Fetch if URL provided
                    if (inputUrl.value && !content) {
                        try {
                            const target = inputUrl.value;
                            // Use our own proxy to bypass CORS
                            const proxyUrl = `/api/proxy?url=${encodeURIComponent(target)}`;
                            const res = await fetch(proxyUrl);
                            if (!res.ok) throw new Error(`Fetch failed: ${res.status}`);
                            content = await res.text();

                            // Try to detect if it's base64 encoded response (common for subscription links)
                            if (!content.includes('://') && /^[A-Za-z0-9+/=\-_]+$/.test(content.trim())) {
                                content = decodeBase64(content.trim());
                            }
                        } catch (e) {
                            errorMsg.value = `Error: ${e.message}`;
                            loading.value = false;
                            return;
                        }
                    }

                    if (!content) {
                        errorMsg.value = 'Please provide URL or Content.';
                        loading.value = false;
                        return;
                    }

                    // Attempt Base64 decode again if the whole content looks like one big base64 blob
                    const trimmed = content.trim();
                    if (!trimmed.includes('://') && !trimmed.includes('proxies:') && /^[A-Za-z0-9+/=\-_]+$/.test(trimmed)) {
                        try {
                            content = decodeBase64(trimmed);
                        } catch (e) { }
                    }

                    const newProxies = [];

                    // æ£€æŸ¥æ˜¯å¦ä¸º Clash YAML æ ¼å¼ (åŒ…å« proxies:)
                    if (content.includes('proxies:')) {
                        try {
                            // ç®€å•çš„ YAML è§£æï¼šæå– proxies æ•°ç»„ä¸­çš„ JSON å¯¹è±¡
                            const lines = content.split('\n');
                            let inProxies = false;

                            for (const line of lines) {
                                const trimLine = line.trim();

                                if (trimLine === 'proxies:') {
                                    inProxies = true;
                                    continue;
                                }

                                // å¦‚æœé‡åˆ°å…¶ä»–é¡¶çº§é”®ï¼Œåœæ­¢è§£æ
                                if (inProxies && /^[a-z\-]+:/.test(trimLine) && !trimLine.startsWith('-')) {
                                    inProxies = false;
                                }

                                if (inProxies && trimLine.startsWith('- {')) {
                                    // æå– JSON å¯¹è±¡
                                    try {
                                        const jsonStr = trimLine.substring(2); // å»æ‰ "- "
                                        const proxy = JSON.parse(jsonStr);
                                        if (proxy && proxy.server && proxy.type) {
                                            proxy.id = Math.random().toString(36).substr(2, 9);
                                            proxy.raw = jsonStr;
                                            newProxies.push(proxy);
                                        }
                                    } catch (e) { /* å¿½ç•¥è§£æå¤±è´¥çš„è¡Œ */ }
                                } else if (inProxies && trimLine.startsWith('-') && trimLine.includes('name:')) {
                                    // æ ‡å‡† YAML æ ¼å¼ï¼ˆå¤šè¡Œï¼‰
                                    // æš‚ä¸æ”¯æŒï¼Œè¿™ç§æ ¼å¼è¾ƒå¤æ‚
                                }
                            }

                            if (newProxies.length > 0) {
                                console.log(`Parsed ${newProxies.length} proxies from Clash YAML`);
                            }
                        } catch (e) {
                            console.error('YAML parsing error:', e);
                        }
                    }

                    // å¦‚æœ YAML è§£ææ²¡æœ‰ç»“æœï¼Œå°è¯•é€è¡Œè§£æé“¾æ¥æ ¼å¼
                    if (newProxies.length === 0) {
                        const lines = content.split(/[\r\n]+/);

                        for (const line of lines) {
                            const tLine = line.trim();
                            if (!tLine) continue;

                            let p = null;
                            if (tLine.startsWith('vmess://')) p = parseVmess(tLine);
                            else if (tLine.startsWith('vless://')) p = parseStandardLink(tLine, 'vless');
                            else if (tLine.startsWith('trojan://')) p = parseStandardLink(tLine, 'trojan');
                            else if (tLine.startsWith('ss://')) {
                                // Basic SS parsing (not exhaustive)
                                try {
                                    const url = new URL(tLine);
                                    let tag = url.hash.slice(1);
                                    if (tag) tag = decodeURIComponent(tag);
                                    p = {
                                        id: Math.random().toString(36).substr(2, 9),
                                        name: tag || 'SS Node',
                                        type: 'ss',
                                        server: url.hostname,
                                        port: url.port,
                                        raw: tLine
                                    };
                                } catch (e) {
                                    // Try legacy base64 format ss://BASE64#TAG
                                    if (tLine.includes('#')) {
                                        p = {
                                            id: Math.random().toString(36).substr(2, 9),
                                            name: decodeURIComponent(tLine.split('#')[1]),
                                            type: 'ss',
                                            server: 'Legacy',
                                            port: 0,
                                            raw: tLine,
                                            tls: false
                                        };
                                    }
                                }
                            } else if (tLine.startsWith('hysteria2://') || tLine.startsWith('hy2://')) {
                                p = parseStandardLink(tLine.replace('hysteria2://', 'https://').replace('hy2://', 'https://'), 'hysteria2'); // cheat URL parser
                                if (p) { p.type = 'hysteria2'; p.raw = tLine; }
                            }

                            if (p) newProxies.push(p);
                        }
                    } // End of link parsing if block

                    if (newProxies.length === 0) {
                        errorMsg.value = 'No parsable nodes found.';
                    } else {
                        // æ ‡è®°ä¸ºæ‰‹åŠ¨æ·»åŠ 
                        newProxies.forEach(p => {
                            p.isManual = true;
                        });

                        // Deduplicate based on raw link
                        const existing = new Set(proxies.value.map(x => x.raw));
                        const added = newProxies.filter(x => !existing.has(x.raw));

                        if (added.length > 0) {
                            // ä¿å­˜åˆ°æœåŠ¡å™¨çš„æ‰‹åŠ¨èŠ‚ç‚¹æ–‡ä»¶
                            try {
                                await fetch('/api/manual_proxies', {
                                    method: 'POST',
                                    headers: { 'Content-Type': 'application/json' },
                                    body: JSON.stringify({ proxies: added })
                                });
                                // é‡æ–°åŠ è½½æ‰€æœ‰èŠ‚ç‚¹ï¼ˆåŒ…æ‹¬æ–°æ·»åŠ çš„ï¼‰ä»¥ç¡®ä¿ç•Œé¢åŒæ­¥
                                await loadProxies();
                            } catch (e) {
                                console.error('ä¿å­˜æ‰‹åŠ¨èŠ‚ç‚¹å¤±è´¥:', e);
                                // å³ä½¿ä¿å­˜å¤±è´¥ï¼Œä¹Ÿå…ˆæ›´æ–°æœ¬åœ°æ˜¾ç¤º
                                proxies.value = [...proxies.value, ...added];
                            }

                            showToast(`å¯¼å…¥ ${added.length} ä¸ªèŠ‚ç‚¹æˆåŠŸ (å·²ä¿å­˜ä¸ºæ‰‹åŠ¨èŠ‚ç‚¹)`);
                            rawContent.value = '';
                            inputUrl.value = '';
                        } else {
                            showToast('æ‰€æœ‰èŠ‚ç‚¹å·²å­˜åœ¨');
                        }
                    }
                    loading.value = false;
                };

                // åŠ è½½æ‰‹åŠ¨èŠ‚ç‚¹åˆ—è¡¨
                const loadManualProxies = async () => {
                    try {
                        const res = await fetch('/api/manual_proxies');
                        const data = await res.json();
                        manualProxies.value = data;
                    } catch (e) {
                        console.error('åŠ è½½æ‰‹åŠ¨èŠ‚ç‚¹å¤±è´¥:', e);
                    }
                };

                // åˆ é™¤æ‰‹åŠ¨èŠ‚ç‚¹
                const deleteManualProxy = async (proxy) => {
                    if (!proxy.id) return;

                    try {
                        await fetch('/api/manual_proxies', {
                            method: 'DELETE',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ ids: [proxy.id] })
                        });

                        // ä»æœ¬åœ°åˆ—è¡¨ä¸­ç§»é™¤
                        proxies.value = proxies.value.filter(p => p.id !== proxy.id);
                        manualProxies.value = manualProxies.value.filter(p => p.id !== proxy.id);

                        showToast('èŠ‚ç‚¹å·²åˆ é™¤');
                    } catch (e) {
                        console.error('åˆ é™¤æ‰‹åŠ¨èŠ‚ç‚¹å¤±è´¥:', e);
                        showToast('åˆ é™¤å¤±è´¥');
                    }
                };

                // ä» Linux.do å¯¼å…¥èŠ‚ç‚¹
                const importFromLinuxDo = async () => {
                    if (linuxDoLoading.value) return;
                    linuxDoLoading.value = true;
                    showLogModal.value = true;
                    serverLogs.value = []; // æ¸…ç©ºä¹‹å‰çš„æ—¥å¿—
                    showToast('å¼€å§‹ä» Linux.do æŠ“å–èŠ‚ç‚¹...');

                    // å¯åŠ¨æ—¥å¿—è½®è¯¢ï¼ˆå®æ—¶æ˜¾ç¤ºè¿›åº¦ï¼‰
                    const logPoller = setInterval(async () => {
                        try {
                            const statusRes = await fetch('/api/status');
                            const state = await statusRes.json();
                            if (state.logs && Array.isArray(state.logs)) {
                                serverLogs.value = state.logs;
                            }
                            serverStats.value = {
                                total: state.total || 0,
                                active: state.active || 0
                            };
                        } catch (e) {
                            // å¿½ç•¥è½®è¯¢é”™è¯¯
                        }
                    }, 500); // æ¯500msæ›´æ–°ä¸€æ¬¡

                    try {
                        const res = await fetch('/api/import_linuxdo', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' }
                        });

                        // åœæ­¢è½®è¯¢
                        clearInterval(logPoller);

                        // æœ€åè·å–ä¸€æ¬¡æ—¥å¿—
                        try {
                            const finalStatus = await fetch('/api/status');
                            const finalState = await finalStatus.json();
                            if (finalState.logs && Array.isArray(finalState.logs)) {
                                serverLogs.value = finalState.logs;
                            }
                        } catch (e) { }

                        const data = await res.json();

                        if (data.success) {
                            let importedCount = 0;

                            // ç›´æ¥ä½¿ç”¨åç«¯è§£æçš„èŠ‚ç‚¹ï¼ˆå·²å¸¦æœ‰è®ºå›æ ‡è®°ï¼‰
                            if (data.parsedProxies && data.parsedProxies.length > 0) {
                                // å»é‡å¹¶åˆå¹¶
                                const existing = new Set(proxies.value.map(x => x.raw));
                                const newProxies = data.parsedProxies.filter(x => !existing.has(x.raw));

                                if (newProxies.length > 0) {
                                    // ä¿å­˜åˆ°æœåŠ¡å™¨çš„æ‰‹åŠ¨èŠ‚ç‚¹æ–‡ä»¶ï¼ˆå¸¦è®ºå›æ ‡è®°ï¼‰
                                    try {
                                        await fetch('/api/manual_proxies', {
                                            method: 'POST',
                                            headers: { 'Content-Type': 'application/json' },
                                            body: JSON.stringify({ proxies: newProxies })
                                        });
                                    } catch (e) {
                                        console.error('ä¿å­˜è®ºå›èŠ‚ç‚¹å¤±è´¥:', e);
                                    }

                                    proxies.value = [...proxies.value, ...newProxies];
                                    importedCount = newProxies.length;
                                }
                            }

                            // å¤„ç†è®¢é˜…é“¾æ¥ï¼ˆé€ä¸ªè§£æï¼Œä¹Ÿæ ‡è®°ä¸ºè®ºå›æ¥æºï¼‰
                            if (data.subscriptions && data.subscriptions.length > 0) {
                                showToast(`å‘ç° ${data.subscriptions.length} ä¸ªè®¢é˜…é“¾æ¥ï¼Œå¼€å§‹è§£æ...`);

                                for (const subUrl of data.subscriptions.slice(0, 10)) { // æœ€å¤šå¤„ç†10ä¸ªè®¢é˜…
                                    try {
                                        // ä½¿ç”¨ä»£ç†è·å–è®¢é˜…å†…å®¹
                                        const proxyUrl = `/api/proxy?url=${encodeURIComponent(subUrl)}`;
                                        const subRes = await fetch(proxyUrl);
                                        if (!subRes.ok) continue;

                                        let content = await subRes.text();

                                        // å°è¯• Base64 è§£ç 
                                        if (!content.includes('://') && /^[A-Za-z0-9+/=\-_]+$/.test(content.trim())) {
                                            try {
                                                content = decodeURIComponent(escape(atob(content.trim().replace(/-/g, "+").replace(/_/g, "/"))));
                                            } catch (e) { }
                                        }

                                        // ç®€å•è§£æèŠ‚ç‚¹é“¾æ¥
                                        const lines = content.split(/[\r\n]+/);
                                        const subProxies = [];

                                        for (const line of lines) {
                                            const tLine = line.trim();
                                            if (!tLine) continue;

                                            let p = null;
                                            if (tLine.startsWith('vmess://')) p = parseVmess(tLine);
                                            else if (tLine.startsWith('vless://')) p = parseStandardLink(tLine, 'vless');
                                            else if (tLine.startsWith('trojan://')) p = parseStandardLink(tLine, 'trojan');
                                            else if (tLine.startsWith('ss://')) {
                                                try {
                                                    const url = new URL(tLine);
                                                    p = {
                                                        id: Math.random().toString(36).substr(2, 9),
                                                        name: decodeURIComponent(url.hash.slice(1)) || 'SS Node',
                                                        type: 'ss',
                                                        server: url.hostname,
                                                        port: url.port,
                                                        raw: tLine
                                                    };
                                                } catch (e) { }
                                            } else if (tLine.startsWith('hysteria2://') || tLine.startsWith('hy2://')) {
                                                p = parseStandardLink(tLine.replace('hysteria2://', 'https://').replace('hy2://', 'https://'), 'hysteria2');
                                                if (p) { p.type = 'hysteria2'; p.raw = tLine; }
                                            }

                                            if (p) {
                                                // æ ‡è®°ä¸ºè®ºå›æ¥æº
                                                p.isFromForum = true;
                                                p.forumSource = 'linux.do';
                                                p.importedAt = new Date().toISOString();
                                                subProxies.push(p);
                                            }
                                        }

                                        // å»é‡å¹¶æ·»åŠ 
                                        const existing = new Set(proxies.value.map(x => x.raw));
                                        const newSubProxies = subProxies.filter(x => !existing.has(x.raw));
                                        if (newSubProxies.length > 0) {
                                            // ä¿å­˜åˆ°æœåŠ¡å™¨
                                            try {
                                                await fetch('/api/manual_proxies', {
                                                    method: 'POST',
                                                    headers: { 'Content-Type': 'application/json' },
                                                    body: JSON.stringify({ proxies: newSubProxies })
                                                });
                                            } catch (e) { }
                                            proxies.value = [...proxies.value, ...newSubProxies];
                                            importedCount += newSubProxies.length;
                                        }
                                    } catch (e) {
                                        console.error('è§£æè®¢é˜…å¤±è´¥:', subUrl, e);
                                    }
                                }
                            }

                            showToast(`Linux.do å¯¼å…¥å®Œæˆï¼å¤„ç†äº† ${data.topicsProcessed} ä¸ªå¸–å­ï¼Œå¯¼å…¥ ${importedCount} ä¸ªèŠ‚ç‚¹`);
                        } else {
                            showToast('å¯¼å…¥å¤±è´¥: ' + (data.error || 'æœªçŸ¥é”™è¯¯'));
                        }
                    } catch (e) {
                        console.error('Linux.do å¯¼å…¥å¤±è´¥:', e);
                        showToast('å¯¼å…¥å¤±è´¥: ' + e.message);
                        // ç¡®ä¿åœæ­¢è½®è¯¢
                        if (typeof logPoller !== 'undefined') {
                            clearInterval(logPoller);
                        }
                    } finally {
                        linuxDoLoading.value = false;
                        inputUrl.value = '';
                        rawContent.value = '';
                        // åˆ·æ–°æ‰‹åŠ¨èŠ‚ç‚¹åˆ—è¡¨
                        await loadManualProxies();
                    }
                };

                // Telegram é¢‘é“ä»»åŠ¡ç›¸å…³å‡½æ•°
                const fetchTelegramStatus = async () => {
                    try {
                        const res = await fetch('/api/telegram/status');
                        const data = await res.json();
                        telegramStatus.value = data;
                        telegramTaskRunning.value = data.isScheduled;
                    } catch (e) {
                        console.error('è·å– Telegram çŠ¶æ€å¤±è´¥:', e);
                    }
                };

                const toggleTelegramTask = async () => {
                    telegramLoading.value = true;
                    try {
                        if (telegramTaskRunning.value) {
                            // åœæ­¢ä»»åŠ¡
                            await fetch('/api/telegram/stop', { method: 'POST' });
                            showToast('Telegram ä»»åŠ¡å·²åœæ­¢');
                            if (telegramStatusPoller) {
                                clearInterval(telegramStatusPoller);
                                telegramStatusPoller = null;
                            }
                        } else {
                            // å¯åŠ¨ä»»åŠ¡
                            await fetch('/api/telegram/start', {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({ intervalMinutes: 30 })
                            });
                            showToast('Telegram ä»»åŠ¡å·²å¯åŠ¨ï¼Œæ¯30åˆ†é’Ÿè‡ªåŠ¨æ›´æ–°');
                            // å¼€å§‹çŠ¶æ€è½®è¯¢
                            telegramStatusPoller = setInterval(fetchTelegramStatus, 2000);
                        }
                        await fetchTelegramStatus();
                        // åŠ è½½ Telegram èŠ‚ç‚¹
                        await loadTelegramProxies();
                    } catch (e) {
                        showToast('æ“ä½œå¤±è´¥: ' + e.message);
                    } finally {
                        telegramLoading.value = false;
                    }
                };

                const loadTelegramProxies = async () => {
                    try {
                        const res = await fetch('/api/telegram/proxies');
                        const data = await res.json();
                        if (Array.isArray(data) && data.length > 0) {
                            // åˆå¹¶åˆ°ä¸»èŠ‚ç‚¹åˆ—è¡¨
                            const existingRaws = new Set(proxies.value.map(p => p.raw));
                            const newNodes = data.filter(n => !existingRaws.has(n.raw));
                            if (newNodes.length > 0) {
                                proxies.value = [...proxies.value, ...newNodes];
                                showToast(`å·²åŠ è½½ ${newNodes.length} ä¸ª Telegram èŠ‚ç‚¹`);
                            }
                        }
                    } catch (e) {
                        console.error('åŠ è½½ Telegram èŠ‚ç‚¹å¤±è´¥:', e);
                    }
                };

                const formatTime = (isoString) => {
                    if (!isoString) return '';
                    const date = new Date(isoString);
                    return date.toLocaleTimeString('zh-CN', { hour: '2-digit', minute: '2-digit' });
                };

                // åˆå§‹åŒ–æ—¶è·å– Telegram çŠ¶æ€
                fetchTelegramStatus();

                const checkLocalConnectivity = async () => {
                    if (isLocalChecking.value) return;
                    isLocalChecking.value = true;
                    hideFailed.value = true; // Auto hide invalid immediately when starting
                    showToast('å¼€å§‹æœ¬åœ°çœŸè¿æ¥æµ‹è¯•...');
                    // sortMode.value = 'local'; // switch sort to see results

                    const candidates = proxies.value; // check all
                    // Reset status for all before starting, so they appear in list (pending)
                    candidates.forEach(p => p.localLatency = undefined);

                    const total = candidates.length;
                    let done = 0;

                    // Client-side parallelism
                    const concurrency = 20;
                    for (let i = 0; i < total; i += concurrency) {
                        const batch = candidates.slice(i, i + concurrency);
                        localCheckProgress.value = `${done}/${total}`;

                        await Promise.all(batch.map(async (p) => {
                            const start = Date.now();
                            const isTls = p.tls === true || p.port === 443;

                            // Browser limitation: can only test TLS (HTTPS) from HTTPS page
                            if (!isTls) {
                                p.localLatency = 99999; // Skip non-TLS
                                return;
                            }

                            const timeout = 3000;
                            try {
                                const controller = new AbortController();
                                const id = setTimeout(() => controller.abort(), timeout);

                                // fetch with no-cors. 
                                // Successful resolution means server accepted connection + SSL handshake.
                                await fetch(`https://${p.server}:${p.port}/`, {
                                    mode: 'no-cors',
                                    signal: controller.signal,
                                    cache: 'no-store'
                                });
                                clearTimeout(id);
                                p.localLatency = Date.now() - start;
                            } catch (e) {
                                // STRICT MODE: Any network error (RST, Cert Fail, Closed) = Fail
                                // This filters out blocked IPs (RST) and bad nodes.
                                p.localLatency = -1;
                            }
                        }));
                        done += batch.length;
                        // small pause for browser loop
                        if (i % 100 === 0) await new Promise(r => setTimeout(r, 100));
                    }

                    isLocalChecking.value = false;
                    hideFailed.value = true; // Auto hide invalid on completion
                    const validCount = candidates.filter(p => p.localLatency > 0 && p.localLatency < 10000).length;
                    showToast(`æµ‹è¯•å®Œæˆï¼æœ‰æ•ˆèŠ‚ç‚¹: ${validCount} / ${total}`);
                };

                const clearProxies = () => {
                    showClearModal.value = true;
                };

                const confirmClear = async () => {
                    try {
                        // å…ˆè°ƒç”¨æœåŠ¡å™¨ API æ¸…ç©ºæ‰€æœ‰èŠ‚ç‚¹æ–‡ä»¶
                        const res = await fetch('/api/clear_all', { method: 'POST' });
                        const data = await res.json();

                        if (data.success) {
                            proxies.value = [];
                            manualProxies.value = [];
                            selectedIds.value = new Set();
                            showClearModal.value = false;
                            showToast('å·²æ¸…ç©ºæ‰€æœ‰èŠ‚ç‚¹');
                        } else {
                            showToast('æ¸…ç©ºå¤±è´¥: ' + (data.error || 'æœªçŸ¥é”™è¯¯'));
                        }
                    } catch (e) {
                        console.error('æ¸…ç©ºèŠ‚ç‚¹å¤±è´¥:', e);
                        showToast('æ¸…ç©ºå¤±è´¥: ' + e.message);
                    }
                };

                const deleteProxy = (id) => {
                    proxies.value = proxies.value.filter(p => p.id !== id);
                };

                // --- Export Logic ---
                const exportConfig = async (format) => {
                    // 1. ç¡®å®šè¦å¤„ç†çš„èŠ‚ç‚¹é›†åˆ (å·²é€‰ or å…¨éƒ¨)
                    let candidates = [];
                    if (selectedCount.value > 0) {
                        const s = selectedIds.value;
                        candidates = proxies.value.filter(p => s.has(p.id));
                    } else {
                        // å¦‚æœæœ‰è¿‡æ»¤æ¡ä»¶ï¼ˆå¦‚ä»…æ˜¾ç¤ºTGï¼‰ï¼Œåˆ™åªå¯¼å‡ºå½“å‰è§†å›¾çš„èŠ‚ç‚¹
                        candidates = filteredProxies.value;
                    }

                    if (candidates.length === 0) return showToast('å½“å‰åˆ—è¡¨æ²¡æœ‰èŠ‚ç‚¹å¯å¯¼å‡º');

                    // 2. æ™ºèƒ½è¿‡æ»¤é€»è¾‘
                    // æ£€æŸ¥æ˜¯å¦è¿›è¡Œè¿‡æœ¬åœ°æµ‹è¯• (è‡³å°‘æœ‰ä¸€ä¸ªèŠ‚ç‚¹æœ‰ localLatency çŠ¶æ€)
                    const hasTestResults = proxies.value.some(p => typeof p.localLatency !== 'undefined');

                    let nodesToExport = [];

                    if (hasTestResults) {
                        // å¦‚æœè¿›è¡Œè¿‡æµ‹è¯•ï¼Œä¸¥æ ¼åªå¯¼å‡ºè¿æ¥æˆåŠŸçš„èŠ‚ç‚¹
                        nodesToExport = candidates.filter(p => p.localLatency > 0 && p.localLatency < 20000);

                        if (nodesToExport.length === 0) {
                            if (confirm('å½“å‰é€‰ä¸­çš„èŠ‚ç‚¹å…¨éƒ¨è¶…æ—¶æˆ–ä¸å¯ç”¨ã€‚æ˜¯å¦å¼ºåˆ¶å¯¼å‡ºæ‰€æœ‰èŠ‚ç‚¹ï¼Ÿ(å¯èƒ½æ— æ³•è¿æ¥)')) {
                                nodesToExport = candidates;
                            } else {
                                return;
                            }
                        } else if (nodesToExport.length < candidates.length) {
                            showToast(`å·²è‡ªåŠ¨è¿‡æ»¤ ${candidates.length - nodesToExport.length} ä¸ªè¶…æ—¶èŠ‚ç‚¹`);
                        }
                    } else {
                        // æœªæµ‹è¯•ï¼Œç›´æ¥å¯¼å‡ºæ‰€æœ‰
                        nodesToExport = candidates;
                        showToast('å»ºè®®å…ˆè¿è¡Œâ€œæœåŠ¡å™¨ç›´è¿æµ‹è¯•â€ä»¥è¿‡æ»¤æ— æ•ˆèŠ‚ç‚¹');
                    }

                    if (format === 'base64') {
                        const rawList = nodesToExport.map(p => p.raw).join('\n');
                        const content = btoa(unescape(encodeURIComponent(rawList)));
                        const blob = new Blob([content], { type: 'text/plain' });
                        const url = URL.createObjectURL(blob);
                        const a = document.createElement('a');
                        a.href = url;
                        a.download = `aggregator_base64_${new Date().toISOString().slice(0, 10)}.txt`;
                        document.body.appendChild(a);
                        a.click();
                        document.body.removeChild(a);
                        return;
                    }

                    // For Clash / Singbox
                    try {
                        let endpoint = '/api/convert';
                        let body = { proxies: nodesToExport, type: format === 'clash' ? 'clash' : 'singbox' };

                        const res = await fetch(endpoint, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(body)
                        });

                        if (!res.ok) {
                            const txt = await res.text();
                            throw new Error(txt || 'Server Error');
                        }

                        const blob = await res.blob();
                        const url = window.URL.createObjectURL(blob);
                        const a = document.createElement('a');
                        a.href = url;
                        const ext = format === 'clash' ? 'yaml' : 'json';
                        a.download = `config_${format}_${new Date().toISOString().slice(0, 10)}.${ext}`;
                        a.click();
                        window.URL.revokeObjectURL(url);
                        showToast(`å·²æˆåŠŸå¯¼å‡º ${nodesToExport.length} ä¸ªå¯ç”¨èŠ‚ç‚¹`);

                    } catch (e) {
                        console.error(e);
                        alert('å¯¼å‡ºå¤±è´¥: ' + e.message);
                    }
                };




                // --- Toast ---
                const toastMsg = ref('');
                const showToast = (msg) => {
                    toastMsg.value = msg;
                    setTimeout(() => toastMsg.value = '', 3000);
                };

                // --- Cloud Aggregation ---
                const cloudLoading = ref(false);
                const cloudResult = ref('');

                // Show modal automatically when cloud loading starts
                watch(cloudLoading, (newVal) => {
                    if (newVal) showLogModal.value = true;
                });

                const fetchCloudProxies = async () => {
                    try {
                        const res = await fetch('/api/proxies');
                        if (res.ok) {
                            const cloudList = await res.json();
                            if (Array.isArray(cloudList) && cloudList.length > 0) {
                                const existing = new Set(proxies.value.map(x => x.raw));
                                const added = cloudList.filter(x => !existing.has(x.raw));
                                proxies.value = [...proxies.value, ...added];
                            }
                        }
                    } catch (e) { console.error('Silent cloud fetch failed', e); }
                };

                const refreshCloud = async () => {
                    if (cloudLoading.value) return;
                    cloudLoading.value = true;
                    // Reset Logs
                    serverLogs.value = [];

                    try {
                        const res = await fetch('/api/refresh', { method: 'POST' });
                        const json = await res.json();

                        if (!json.success && json.status !== 'fetching' && json.status !== 'testing') {
                            showToast(`Error: ${json.message}`);
                            cloudLoading.value = false;
                            return;
                        }

                        // Use common poller
                        pollStatus();

                    } catch (e) {
                        showToast(`Network Error: ${e.message}`);
                        cloudLoading.value = false;
                    }
                };

                // --- Auto Purity Checker ---
                const autoCheckCount = ref(0);

                const startAutoChecker = async () => {
                    console.log('Auto-checker started (Batch Mode)');

                    while (true) {
                        try {
                            // Find candidates
                            // Priority 1: Current page
                            let pageCandidates = filteredProxies.value.filter(p => !p.purity && !p.checking && !p.failedCheck);
                            let others = proxies.value.filter(p => !p.purity && !p.checking && !p.failedCheck);

                            // Combine candidates, prioritizing pageCandidates
                            let batch = [];
                            const batchSize = 25; // ip-api batch supports up to 100, but let's be conservative to avoid timeouts

                            if (pageCandidates.length > 0) {
                                batch = pageCandidates.slice(0, batchSize);
                            }

                            // Fill remaining slots with others if needed
                            if (batch.length < batchSize) {
                                let needed = batchSize - batch.length;
                                // Filter out already added ones
                                const currentIds = new Set(batch.map(p => p.id));
                                for (let p of others) {
                                    if (!currentIds.has(p.id)) {
                                        batch.push(p);
                                        if (batch.length >= batchSize) break;
                                    }
                                }
                            }

                            if (batch.length > 0) {
                                // Update count
                                autoCheckCount.value = proxies.value.filter(p => !p.purity && !p.failedCheck).length;

                                await checkBatchPurity(batch);

                                // Rate Limit Protection:
                                // Batch endpoint limit: 15 requests per minute.
                                // 60s / 15 = 4s interval.
                                // Increased to 8000ms to be safe and avoid 429
                                await new Promise(r => setTimeout(r, 8000));
                            } else {
                                autoCheckCount.value = 0;
                                await new Promise(r => setTimeout(r, 3000));
                            }
                        } catch (e) {
                            console.error('Checker error', e);
                            await new Promise(r => setTimeout(r, 5000));
                        }
                    }
                };

                const checkBatchPurity = async (nodes) => {
                    if (nodes.length === 0) return;

                    // Mark all as checking
                    nodes.forEach(n => n.checking = true);

                    try {
                        const ips = nodes.map(n => n.server);
                        const res = await fetch('/api/check_ip_batch', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(ips)
                        });

                        if (res.ok) {
                            const results = await res.json(); // Array of results
                            if (Array.isArray(results)) {
                                // Map results back to nodes
                                // The order SHOULD be preserved but let's map by query IP to be safe if API returns unordered?
                                // Actually ip-api batch returns in order, but objects have "query" field.

                                const resultMap = {};
                                results.forEach(r => {
                                    if (r && r.query) resultMap[r.query] = r;
                                });

                                nodes.forEach(node => {
                                    node.checking = false; // Always clear checking flag
                                    const data = resultMap[node.server];
                                    if (data && data.status === 'success') {
                                        let score = 100;
                                        if (data.hosting) score -= 40; else score += 5;
                                        const isp = (data.isp || '').toLowerCase();
                                        if (isp.includes('google') || isp.includes('amazon') || isp.includes('cloud') || isp.includes('microsoft')) {
                                            score -= 10;
                                        }
                                        node.purity = {
                                            countryCode: data.countryCode,
                                            isp: data.isp,
                                            hosting: data.hosting
                                        };
                                        node.purityScore = Math.max(0, Math.min(100, score));
                                    } else {
                                        // console.warn('Purity check failed for', node.server, data);
                                        node.failedCheck = true;
                                    }
                                });
                            } else {
                                nodes.forEach(n => { n.checking = false; n.failedCheck = true; });
                            }
                        } else {
                            console.error('Purity Batch API Error', res.status, res.statusText);
                            nodes.forEach(n => { n.checking = false; n.failedCheck = true; });
                        }
                    } catch (e) {
                        console.error('Batch check failed', e);
                        nodes.forEach(n => { n.checking = false; n.failedCheck = true; });
                    }
                };



                // Keep single check for manual clicks if needed (though UI button calls checkNodePurity, we can redirect it)
                const checkNodePurity = async (node) => {
                    // Redirect manual check to batch logic (single item batch)
                    await checkBatchPurity([node]);
                };

                // --- Server Status Sync ---
                const serverStats = ref({ total: 0, active: 0 });

                const checkServerStatus = async () => {
                    try {
                        const res = await fetch('/api/status');
                        const state = await res.json();

                        if (state.status !== 'idle') {
                            // Resume monitoring
                            cloudLoading.value = true;
                            serverLogs.value = state.logs || [];
                            showLogModal.value = true; // Auto-open if running
                            pollStatus();
                        }
                    } catch (e) {
                        console.error('Failed to sync server status', e);
                    }
                };

                const pollStatus = () => {
                    const interval = setInterval(async () => {
                        try {
                            const sRes = await fetch('/api/status');
                            const state = await sRes.json();

                            // Update Logs Real-time
                            if (state.logs && Array.isArray(state.logs)) {
                                serverLogs.value = state.logs;
                            }

                            // Update Stats
                            serverStats.value = {
                                total: state.total || 0,
                                active: state.active || 0
                            };

                            if (state.status === 'idle') {
                                clearInterval(interval);
                                cloudResult.value = 'Complete';
                                showToast('äº‘ç«¯èšåˆå®Œæˆ');
                                await loadProxies(); // Reload all proxies from server
                                cloudLoading.value = false;

                                // Auto-close log window after a short delay
                                setTimeout(() => {
                                    showLogModal.value = false;
                                }, 1500);
                            }
                        } catch (e) {
                            clearInterval(interval);
                            cloudLoading.value = false;
                        }
                    }, 1000);
                };

                onMounted(async () => {
                    // ä»æœåŠ¡å™¨åŠ è½½æ‰€æœ‰èŠ‚ç‚¹ï¼ˆäº‘ç«¯ + æ‰‹åŠ¨ï¼‰
                    await loadProxies();

                    // Sync with potentially running background process
                    checkServerStatus();

                    // Start Background Worker (Purity Check)
                    startAutoChecker();
                });

                return {
                    inputUrl, rawContent, proxies, loading, errorMsg, searchQuery, sortMode,
                    showImportParams, showExportModal, showClearModal, showLogModal, // Added showLogModal
                    toastMsg,
                    parseContent, clearProxies, confirmClear, deleteProxy, exportConfig,
                    filteredProxies, protocols, protocolStats, getProtocolColor, getProtocolBadgeColor,
                    cloudLoading, cloudResult, refreshCloud, checkNodePurity, autoCheckCount, serverLogs, logWindowRef, // Added logs
                    currentPage, totalPages, nextPage, prevPage,
                    getCountry, proxiesByType,
                    selectedIds, toggleSelection, clearSelection, selectedCount, toggleSelectPage, pageSelected,
                    purityChecking, checkSelectedPurity, // çº¯å‡€åº¦æ£€æŸ¥ç›¸å…³
                    filterType, filterCountry, countries, countryStats,
                    isLocalChecking, localCheckProgress, checkLocalConnectivity, hideFailed, totalVisibleCount, pageSize,
                    modalStyle, startDrag, logWindowEl, serverStats, // Export serverStats
                    showManualOnly, manualProxies, loadManualProxies, deleteManualProxy, // æ‰‹åŠ¨èŠ‚ç‚¹ç›¸å…³
                    showForumOnly, forumProxiesCount, // è®ºå›æœç´¢ç›¸å…³
                    showTelegramOnly, telegramProxiesCount, // Telegram ç­›é€‰ç›¸å…³
                    linuxDoLoading, importFromLinuxDo, // Linux.do å¯¼å…¥
                    // Telegram é¢‘é“æŠ“å–ç›¸å…³
                    telegramLoading, telegramTaskRunning, telegramStatus,
                    toggleTelegramTask, fetchTelegramStatus, loadTelegramProxies, formatTime
                };
            }
        }).mount('#app');
    </script>
</body>

</html>